<a name="piCOS"></a>
### 目录
   - [Java集合包](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#Java_1)
      - [01. HashMap的底层数据结构是什么？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#01_HashMap_2)
      - [02. JDK1.8中对hash算法和寻址算法是如何优化的？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#02_JDK18hash_5)
      - [03.HashMap是如何解决hash碰撞问题的？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#03HashMaphash_20)
      - [04.说说HashMap是如何进行扩容的？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#04HashMap_23)
      - [05.ArrayList,LinkedList,TreeMap,LinkedHashMap,HashSet等底层的数据结构和各自的优点和劣势？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#05ArrayListLinkedListTreeMapLinkedHashMapHashSet_34)
   - [Java并发编程](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#Java_37)
      - [01.JAVASE多线程基础回顾](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#01JAVASE_38)
      - [02.synchronized关键字的底层原理以及跟lock锁之间的区别？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#02synchronizedlock_176)
      - [03.聊聊你对CAS的理解以及底层实现原理？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#03CAS_197)
      - [04.ConcurrentHashMap实现线程安全的底层原理是什么？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#04ConcurrentHashMap_229)
      - [05.对JDK中的AQS了解吗？AQS的实现原理是什么？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#05JDKAQSAQS_257)
      - [06.说说线程池的底层工做原理？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#06_275)
      - [07.说说线程池的核心配置参数是干什么的？应该怎么用？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#07_300)
      - [08.若是在线程中使用无界阻塞队列会发生什么问题？等同于问，在远程服务异常的状况下，使用无界阻塞队列，是否会致使内存异常飙升？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#08_336)
      - [09.线程池的队列满了以后，会发生什么？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#09_340)
      - [10.若是线上机器忽然宕机，线程池的阻塞队列中的请求怎么办？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#10_351)
      - [11.谈谈对JAVA内存模型的理解？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#11JAVA_360)
      - [12.说说JAVA内存模型中的原子性、有序性、可见性？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#12JAVA_390)
      - [13.能从JAVA底层角度聊聊volatile关键字的原理么？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#13JAVAvolatile_399)
      - [14. 你知道指令重排、内存栅栏以及happens-before这些是什么么？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#14_happensbefore_409)
      - [15.volatile底层是如何基于内存屏障保证可见性和有序性的？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#15volatile_451)
      - [16.能说说ThreadLocal的底层实现原理么？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#16ThreadLocal_466)
   - [Spring](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#Spring_468)
      - [01.说说你对Spring的IOC机制的理解能够嘛？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#01SpringIOC_469)
      - [02.说说你对spring的AOP机制的理解？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#02springAOP_624)
      - [03.了解过cglib动态代理吗？他跟jdk动态代理的区别是什么？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#03cglibjdk_635)
         - [动态的代理的特色](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#_636)
         - [动态代理的两种实现方式](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#_638)
               - [基于接口的动态代理](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#_668)
               - [基于子类的动态代理](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#_739)
         - [二者之间的区别](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#_811)
      - [04.能说说Spring中的Bean是线程安全的吗？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#04SpringBean_816)
      - [05.Spring的事务实现原理是什么？能聊聊你对事务传播机制的理解么？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#05Spring_822)
      - [06.能说说Spring中使用了哪些设计模式吗？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#06Spring_835)
      - [07.能画一张图说一说springMvc的核心架构么？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#07springMvc_839)
   - [JVM](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#JVM_843)
      - [01.JVM中有哪几块内存区域？Java 8 以后对内存分代作了什么改进？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#01JVMJava_8__844)
      - [02.你知道JVM是如何运行起来的吗？咱们的对象是如何分配的？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#02JVM_851)
      - [03.说说JVM在哪些状况下会触发垃圾回收能够吗？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#03JVM_853)
      - [04.说说JVM年轻代的垃圾回收算法？对象何时转移到老年代？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#04JVM_863)
      - [05.说说老年代的垃圾回收算法？经常使用的垃圾回收器都有什么？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#05_877)
      - [06.大家生产环境中的Tomcat是如何设置JVM参数的？如何检查JVM运行状况的？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#06TomcatJVMJVM_893)
      - [07.你在实际项目中是否作过JVM GC优化，怎么作的？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#07JVM_GC_895)
      - [08.谈谈你对java跨平台性的理解？为何java能够一次编译处处运行？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#08javajava_897)
   - [网络](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#_903)
      - [01.你能聊一聊TCPIP四层网络模型嘛？OSI七层网络模型也要说一下！](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#01TCPIPOSI_904)
         - [物理层](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#_905)
         - [数据链路层](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#_908)
         - [网络层](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#_922)
         - [传输层](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#_959)
         - [应用层](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#_970)
      - [02.浏览器请求www.baidu.com的全过程大概是怎么样的？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#02wwwbaiducom_980)
      - [03.TCP三次握手和四次挥手的流程图？为啥不是两次或者五次呢？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#03TCP_989)
      - [04.说一下http的工做流程？http1.0,http1.1,http2.0具体有哪些区别？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#04httphttp10http11http20_1011)
      - [05.聊聊https的工做原理？为啥用https就能够加密通讯？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#05httpshttps_1014)
      - [06.什么是长链接？http长链接是什么？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#06http_1016)
   - [数据库](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#_1022)
      - [01.MySQL MylSAM 和 InnoDB存储引擎的区别是啥？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#01MySQL_MylSAM__InnoDB_1023)
      - [02.MySQL索引的原理和数据结构能介绍一下么？b+树和b-树有什么区别？MySQL聚簇索引和非聚簇索引的区别是什么？他们分别是如何存储的？使用MySQL索引都有哪些原则？MySQL复合索引如何使用？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#02MySQLbbMySQLMySQLMySQL_1029)
      - [03.说说事务的几个特性是什么？有哪几种隔离级别？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#03_1048)
         - [什么是事务](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#_1050)
         - [事务中的四大特性？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#_1053)
         - [不考虑隔离会产生的三个问题？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#_1060)
         - [解决上述问题的方案？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#_1082)
      - [04. 你能说说MySql数据库锁的实现原理吗？若是死锁了怎么办？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#04_MySql_1099)
      - [05.MySQL的SQL调优通常都有哪些手段？大家通常怎么作？](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#05MySQLSQL_1125)
   - [涉及到的知识补充](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#_1128)
      - [单例设计模式](https://www.shangmayuan.com/a/d800fd7605224b83a101304b.html#_1129)
<a name="lOrvi"></a>
## Java集合包
<a name="eYwoU"></a>
### 01. HashMap的底层数据结构是什么？
![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783517006-5c6cc350-650b-47de-afd6-f1a620698988.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=ub22d09cc&margin=%5Bobject%20Object%5D&originHeight=521&originWidth=799&originalType=url&ratio=1&status=done&style=none&taskId=udb65a2eb-ff3e-4c9a-9da3-07eeab6b4a7)<br />哈希表底层数据结构实际上就是数组。它利用数组支持按照下标随机访问的时候，时间复杂度是o(1)的特性。咱们经过哈希函数把元素的键值映射为下标，而后将数据存储在数组中对应下标的位置。当咱们按照键值查询元素时，咱们使用相同的哈希函数，将键值转化为数组下标，从对应的数组下标的位置取出数据。html
<a name="JJBnO"></a>
### 02. JDK1.8中对hash算法和寻址算法是如何优化的？
```java
//JDK1.8之后的HashMap部分源码
static final int hash(Object key){
	int h;
	return (key == null)?0(h=key.hashCode())^(h>>>16);
}
```
**hash算法的优化：**<br />	对每一个hash值，将他的高低十六位进行异或操做，让低十六位同时保持了高低十六位的特征。同时也能够避免一些hash值后续出现冲突。前端<br />**寻址算法的优化：**<br />	寻址算法就是对长度为n的数组取模，获得在数组中的位置。**根据数学规律，对n取模，就是和n-1进行与运算**。与运算的效率远远高于求模运算，因此采用与运算。而数组的长度一般没有很大，因此高位与出来都是0，若是不进行hash算法优化，那么高位的信息就会丢失。<br />综上就是JDK8的hash算法的优化。java
<a name="rbCFH"></a>
### 03.HashMap是如何解决hash碰撞问题的？
**hash冲突问题， 链表 + 红黑树 ，o(n)和o(logn)**<br />当发生hash冲突时，会在数组中重复的位置放置一个链表，而后将value的值加入链表中。可是因为链表的查询时间复杂度是o(n)，因此当链表的变的很长的时候，咱们获取值会变的很慢。为了提高性能，当链表的长度到达必定值时，咱们将链表转换成红黑树，红黑树的查询时间复杂度是o(logn),提高性能。mysql
<a name="SG1OC"></a>
### 04.说说HashMap是如何进行扩容的？
hashMap底层默认是一个数组，当这个数组满了之后，就会自动扩容，变成一个更大的数组，能够在里面放更多的元素。<br />hashMap的默认大小是16位的，当16存满之后就会进行***2倍扩容***，变成长度为32的数组。这个时候就要对原先数组中存储的元素进行rehash，即将他们的哈希值和（32-1）进行与运算，本来在长度为16的处于相同位置的几个元素，可能就要变换位置，不在一样的位置了。<br />为何进行两倍扩容？<br />两倍扩容就是二进制位的上一位变成1，好比<br />0000 0000 0000 1111<br />变成<br />0000 0000 0001 1111<br />在进行rehash操做时，判断二进制结果是否多了一个bit的1，若是没多，那么就是原来的index,若是多了，那么就是index + oldcap，经过这个方式，避免rehash的时候，进行取模运算，位运算的性能更高。<br />**注意，咱们最好在使用hashMap的时候可以指定合适的hashMap的大小，来避免扩容，这样就能避免rehash操做，影响性能。**web
<a name="ZL6L5"></a>
### 05.ArrayList,LinkedList,TreeMap,LinkedHashMap,HashSet等底层的数据结构和各自的优点和劣势？
<a name="GkPVR"></a>
## Java并发编程
<a name="GID6z"></a>
### 01.JAVASE多线程基础回顾
![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783516939-3ac2bb04-a359-4e3c-a92e-bab3809f04c4.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=u43d6ad9c&margin=%5Bobject%20Object%5D&originHeight=45&originWidth=794&originalType=url&ratio=1&status=done&style=none&taskId=u01547ede-4017-4ec8-a6ec-8a9e1949e35)![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783516962-815c6ffb-99c9-41ff-ab75-841500f97104.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=u8bde9c46&margin=%5Bobject%20Object%5D&originHeight=539&originWidth=741&originalType=url&ratio=1&status=done&style=none&taskId=ubca3da18-c82f-4c48-b817-331c894e592)<br />注意：建立线程的目的是为了开启一条路径，去运行指定的代码和其它代码同时运行。线程须要任务。算法<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783517006-26a9e1f0-d611-44d6-bb51-b7ac6d597f56.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=u1a6139c8&margin=%5Bobject%20Object%5D&originHeight=131&originWidth=669&originalType=url&ratio=1&status=done&style=none&taskId=u990c9f56-3382-47f8-8277-0e985e01504)<br />**注意要会描述下面这张图**spring<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783516988-484df7fe-7621-4fe7-9843-acb72e7b2a80.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=u30804339&margin=%5Bobject%20Object%5D&originHeight=454&originWidth=843&originalType=url&ratio=1&status=done&style=none&taskId=u009e57a2-304a-41fc-bf74-85744cd78c2)![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783517602-ac416878-411a-4a99-8f21-6426ee2a2c3d.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=ue930757b&margin=%5Bobject%20Object%5D&originHeight=433&originWidth=722&originalType=url&ratio=1&status=done&style=none&taskId=u5a4f25d6-7b02-45b3-840d-b3b96018387)![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783517708-a2782d98-315b-4635-aa22-90eadf14b3d5.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=u8d72ae43&margin=%5Bobject%20Object%5D&originHeight=505&originWidth=746&originalType=url&ratio=1&status=done&style=none&taskId=u7ed9551d-0746-41dd-8e49-85ad86b0d66)<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783517750-ca742358-e6bc-4b78-8b9b-bc47615884fe.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=uc53d98f5&margin=%5Bobject%20Object%5D&originHeight=566&originWidth=745&originalType=url&ratio=1&status=done&style=none&taskId=ude946aa5-2f4f-4db1-b8a2-d830db50921)<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783517750-3b343cef-cccf-43d4-850f-2cf3de89d5c2.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=u950cfb7b&margin=%5Bobject%20Object%5D&originHeight=574&originWidth=759&originalType=url&ratio=1&status=done&style=none&taskId=ub8c47870-3b08-44dc-a915-1dd38546e2d)![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783517778-6fc2a32a-cd54-4aa5-8034-922edef83274.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=ua5d9a892&margin=%5Bobject%20Object%5D&originHeight=571&originWidth=766&originalType=url&ratio=1&status=done&style=none&taskId=u7e86721c-4d5b-48cc-97dd-d153f67230b)
```java
/*
循环的嵌套就会产生同步死锁
注意：通常run方法里都会有循环结构 
分析：
定义线程的第二种方法 
首先定义一个子类实现Runnable接口 复写线程的任务就是覆盖Runnable接口中的run方法
建立任务对象 
建立线程对象 并将任务对象做为参数传入线程对象 
让线程对象获得本身的任务 即本身的run函数
*/

//一段死锁的代码示例

class DeadLock implements Runnable 
{
	private boolean flag;
	DeadLock(boolean flag)
	{
		this.flag = flag;
		
	}
	public void run()
	{
		if (flag)
		{
			while (true)//while 循环开始一段完整的线程 放在if里面
			{
				synchronized (MyLock.locka)
				{
					System.out.println(Thread.currentThread().getName()+"if locka");
					synchronized(MyLock.lockb)
					{
						System.out.println(Thread.currentThread().getName()+"if lockb");
					}
				}
			}
		}
		else
			{
				while (true)
				{
					synchronized (MyLock.lockb)
					{
						System.out.println(Thread.currentThread().getName()+"else lockb");
						synchronized(MyLock.locka)
						{
							System.out.println(Thread.currentThread().getName()+"else locka");
						}
					}
					
				}
					
			}
	}
}
class MyLock
{
	public static final Object locka = new Object();
	public static final Object lockb = new Object();
}
class DeadLockTest 
{
	public static void main(String[] args) 
	{
		DeadLock d1 = new DeadLock(true);
		DeadLock d2 = new DeadLock(false);
		
		Thread t1 = new Thread(d1);
		//d.flag = false;
		Thread t2 = new Thread(d2);
		t1.start();//调用对象的成员函数记得加上括号
		t2.start();
	}
}

```
![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783518208-3b9ab7fd-6d9d-4414-b4c5-d3786eec2f74.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=u08a8bfc0&margin=%5Bobject%20Object%5D&originHeight=526&originWidth=729&originalType=url&ratio=1&status=done&style=none&taskId=u9e1c5682-67d2-4000-a8ae-e45076d08fb)

- [ ] 线程的几个状态？
- [ ] <br />
- [ ] 线程之间的状态怎么切换的？
- [ ] <br />
- [ ] wait和sleep的区别？
- [ ] <br />
- [ ] 上面说到wait之后，会把线程对象存储到线程池中？ 
- [ ] <br />
- [ ] 那当她唤醒之后，还是找个线程帮他执行任务嘛？这里句话有问题吧。

<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783518279-a759ade9-79fa-4477-91f3-216165a668eb.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=u13f88266&margin=%5Bobject%20Object%5D&originHeight=559&originWidth=728&originalType=url&ratio=1&status=done&style=none&taskId=u5923a032-d04f-4cb0-9d2b-567bb173b4a)<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783518387-a7b4a829-adb8-4dda-8847-9329523d6699.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=u9cc405e9&margin=%5Bobject%20Object%5D&originHeight=440&originWidth=735&originalType=url&ratio=1&status=done&style=none&taskId=u17f27a69-0cca-4da4-b975-fd671ae21c5)<br />记住Lock锁是在JDK1.5之后才有的？<br />这里联想一下JDK不同版本之间的区别。。？

一个lock能够挂多个Condition对象，即多个监视器。 <br />Condition c1 = lock.newCondition();//<br />经过已有的锁产生监视器对象 lock接口的出现替代了同步代码块或者同步函数。将同步的隐士锁变成了显示锁。同时更加灵活，能够添加多个监视器。 
```java
class BoundedBuffer {
    final Lock lock = new ReentrantLock();
    final Condition notFull = lock.newCondition();//建立多个监视器，每次唤醒一个，提升效率
    final Condition notEmpty = lock.newCondition();
    final Object[] items = new Object[100];
    int putptr, takeptr, count;

    public void put(Object x) throws InterruptedException {
        lock.lock();//获取锁
        try {
            while (count == items.length)
                notFull.await();
            items[putptr] = x;
            if (++putptr == items.length) putptr = 0;
            ++count;
            notEmpty.signal();
        } finally {
            lock.unlock();//释放锁
        }
    }

    public Object take() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0)
                notEmpty.await();
            Object x = items[takeptr];
            if (++takeptr == items.length) takeptr = 0;
            --count;
            notFull.signal();
            return x;
        } finally {
            lock.unlock();
        }
    }
}
```
<a name="t25Ti"></a>
### 02.synchronized关键字的底层原理以及跟lock锁之间的区别？
  使用了synchronized关键字，在底层编译后的jvm指令中，会有monitorenter和monitorexit 两个指令。sql<br />那么monitorenter指令执行的时候会干什么呢？数据库<br />每一个对象都有关联的monitor，若是要对这个对象加锁，就必须获取这个对象关联的monitor的lock锁。<br />monitor里面的原理和思路大概是这样的，monitor里面有一个计数器，从0开始。若是一个线程要获取monitor的锁，就会判断他的计数器是否是0，若是是0，那么说明没有人获取锁，他就能够获取锁，而后对计数器加一。同理释放锁的时候就会减一。（可重入锁的实现原理）<br />若是一个线程来获取montior锁时发现，值不是0，这个线程就会陷入阻塞状态，就会等待计数器变成0而后执行。编程<br />注意monitor的锁是支持重复加锁的，就像下面这段代码
```java
加一次锁monitor计数器就会加一 释放一次就会减一 一直到0表示锁为能够获取的状态
synchronized(myObject){
	//一大堆代码
	synchronized(myObject){
	}
}
```
synchronized和lock的区别<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783518427-f9a34364-138c-4b02-8f44-485e94707b46.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=u1db0e784&margin=%5Bobject%20Object%5D&originHeight=331&originWidth=756&originalType=url&ratio=1&status=done&style=none&taskId=uad3b1e28-d46a-4b22-91aa-154efbba7c7)
<a name="oTtAY"></a>
### 

<a name="GWNi2"></a>
### 03.聊聊你对CAS的理解以及底层实现原理？
上一个讲解的很是好的CAS博客地址：[什么是CAS机制](https://blog.csdn.net/qq_32998153/article/details/79529704?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1)：<br />[https://blog.csdn.net/qq_32998153/article/details/79529704?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1](https://blog.csdn.net/qq_32998153/article/details/79529704?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1)<br />下面是我对CAS的理解和总结：Conmpare And Swap（比较和交换）<br />首先说一说CAS能解决的问题。咱们都知道当多个线程对同一个数据进行操做的时候，若是没有同步就会产生线程安全问题。为了解决线程线程安全问题，咱们须要加上同步代码块，操做，如加上synchronized。可是某些状况下这并非最优选择。

synchronized关键字会让没有获得锁资源的线程进入BLOCKED状态，然后在争夺到锁资源后恢复为RUNNABLE状态，这个过程当中涉及到操做系统用户模式和内核模式的转换，代价比较高。这个过程是一个串行的过程，效率很低。  

- [ ] 什么是用户模式和内核模式的切换问题？

<br />尽管JAVA 1.6为synchronized作了优化，增长了从偏向锁到轻量级锁再到重量级锁的过过分，可是在最终转变为重量级锁以后，性能仍然比较低。因此面对这种状况，咱们就可使用java中的“原子操做类”。

- [ ] synchronized在JDK1.6之后的锁升级过程？



而原子操做类的底层正是用到了“CAS机制”。<br />CAS是英文单词Compare and Swap的缩写，翻译过来就是比较并替换。<br />CAS机制中使用了3个基本操做数：内存地址V，旧的预期值A，要修改的新值B。

更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改成B。(具体实现详细的见上面的博客中介绍）

从思想上来讲，synchronized属于悲观锁，悲观的认为程序中的并发状况严重，因此严防死守，CAS属于乐观锁，乐观地认为程序中的并发状况不那么严重，因此让线程不断去重试更新。

说了这么多，CAS是不是完美的呢，答案也是否认的。下面是说一说CAS的缺点：<br />1） CPU开销过大。线程反复执行<br />在并发量比较高的状况下，若是许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很到的压力。<br />2） 不能保证代码块的原子性，只能保证一个变量原子性，无法整体代码块的原子性。<br />CAS机制所保证的知识一个变量的原子性操做，而不能保证整个代码块的原子性。好比须要保证3个变量共同进行原子性的更新，就不得不使用synchronized了。

3） ABA问题<br />这是CAS机制最大的问题所在。

- [ ] 解释一下什么是ABA问题？

- [ ] 有哪些原子操作类底层是CAS原理的？

<a name="UWI3f"></a>
### 04.ConcurrentHashMap实现线程安全的底层原理是什么？
这里有可能会问到HashMap为什么线程不安全，推荐一篇文章：HashMap会产生的线程安全问题<br />首先聊一聊ConcurrentHashMap存在的必要性，即它能解决的问题。在编程中我们常常要对一个hashMap进行多个线程的操作，这个时候为了避免线程安全问题，我们就要给她加上同步。<br />但是这个时候又会有新的问题产生。
```java
我们知道hashMap的底层实现实际上是数组
多个线程过来，线程1要put的位置是数组[5]，线程二要put的位置是[21]
synchronized(map({
	map.put(xxx,xxx)
}
```
我们可以看到向两个不同的位置添加元素，也被锁管理了，这明显是没有必要的，会造成效率低下。我们需要解决这个问题。JDK并发包里推出了ConcurrentHashMap，默认实现了线程的安全性。<br />下面聊一聊，它是如何实现的。

在JDK 1.7 版本，它的实现方式是分段加锁，将HashMap在底层的数组分段成几个小数组，然后给每个数组分别加锁。

JDK1.8以及之后，做了一些优化和改进，锁粒度的细化。

这里仍然是一个大的数组，数组中每个元素进行put都是有一个不同的锁，刚开始进行put的时候，如果两个线程都是在数组[5]这个位置进行put，这个时候，对数组[5]这个位置进行put的时候，采取的是CAS策略。<br />同一时间，只有一个线程能成功执行CAS，其他线程都会失败。<br />这就实现了分段加锁的第一步，如果很多个线程对数组中不同位置的元素进行操作，大家是互相不会影响的。

如果多个线程对同一个位置进行操作，CAS失败的线程，就会在这个位置基于链表+红黑树来进行处理，synchronized([5]),进行加锁。

综上所述，JDK1.8之后，只有对相同位置的元素操作，才会加锁实行串行化操作，对不同位置进行操作是并发执行的。

<a name="yNhin"></a>
### 05.对JDK中的AQS了解吗？AQS的实现原理是什么？
咱们上面三节分别学习了三种多个线程访问一个<br />共享数据实现线程安全的三种解决方案：synchronized,CAS和ConcurrentHashMap(并发安全的数据结构）。<br />下面介绍最后一种，Lock。它的底层就使用到AQS技术。Abstract Queue Synchronizer,抽象队列同步器
```java
在创建锁时候 可以创建公平锁和非公平锁
创建非公平锁
ReentrantLock lock = new ReentrantLock();//非公平锁
创建公平锁
ReentrantLock lock = new ReentrantLock(true);//公平锁
lock.lock();

lock.unlock();
```

- 非公平锁，就是当线程1结束运行释放锁以后，它去唤醒等待队列中的线程2，但是还没等线程2CAS成功，这时候冒出来一个线程3插队，优先实现加锁，线程2CAS失败，继续等待，这就是非公平锁。
- 公平锁，就是线程3，在想插队时，会进行判断，等待队列中是否还有线程，如果有它就不能插队，会进入等待队列中排队。这就是公平锁。

[

](https://blog.csdn.net/u013073869/article/details/105271345)<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633934954964-d8bdb0ce-eff5-44e5-a9b0-320ccc12c70f.png#clientId=uf3a3b9d2-628b-4&from=paste&height=446&id=u5ae38b67&margin=%5Bobject%20Object%5D&name=image.png&originHeight=892&originWidth=1906&originalType=binary&ratio=1&size=596959&status=done&style=none&taskId=u043de40e-fb87-49ff-84a4-972bf960316&width=953)
<a name="ljnyQ"></a>
### 06.说说线程池的底层工做原理？
首先说一说为何要有线程池。<br />系统是不可能频繁的建立线程有销毁线程的，这样会很是影响性能，因此咱们须要线程池。
```java
 ExecutorService threadPool = Executors.newFixedThreadPool(3);//corePoolSize
threadPool.submit(new Callable<>() {

            @Override
            public Object call() throws Exception {
                return null;
            }
            
        });
```

- 提交任务，先看一下线程池里的线程数量是否小于corePoolSize，也就是3，如果小于，直接创建一个线程出来执行你的任务。

- 如果执行完你的任务之后，这个线程是不会死掉的，他会尝试从一个无界的LinkedBlockingQueue里获取新的任务，如果没有新的任务，此时就会阻塞住，等待新的任务到来

- 你持续提交任务，上述流程反复执行，只要线程池的线程数量小于corePoolSize，都会直接创建新线程来执行这个任务，执行完了就尝试从无界队列里获取任务，直到线程池里有corePoolSize个线程

- 接着再次提交任务，会发现线程数量已经跟corePoolSize一样大了，此时就直接把任务放入队列中就可以了，线程会争抢获取任务执行的，如果所有的线程都在执行任务，无界队列里的任务就可能会越来越多。
- fixed，队列，LinkedBlockingQueue，无界阻塞队列<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633935004872-ea48bd80-cc6e-4ecd-9607-36a25d98d3d1.png#clientId=uf3a3b9d2-628b-4&from=paste&height=330&id=nVDSK&margin=%5Bobject%20Object%5D&name=image.png&originHeight=660&originWidth=1624&originalType=binary&ratio=1&size=326643&status=done&style=none&taskId=u07eb7380-3362-4175-9f00-1d72632416c&width=812)
<a name="mnDrX"></a>
### 
<a name="Y1Y7y"></a>
### 07.说说线程池的核心配置参数是干什么的？应该怎么用？
```java
当我们调用上一节的函数生成fixed线程池的时候
ExecutorService threadPool = Executors.newFixedThreadPool(3);
它的底层执行的代码如下
return new ThreadPoolExecutor(
			nThreads,//corePoolSize
            nThreads,//maximumPoolSize
            0l,//表示等待的时间
            TimeUint.MiLLISECONDS,//代表等待时间是毫秒级别的
            new LinkedBlockingQueue<Runnable>());//线程池放任务的队列
```
上面几个的参数分别是，corePoolSize,maximumPoolSize,keepAliveTime,queue这几个东西，若是你不用fixed之类的线程池，彻底可使用这个构造函数创造本身的线程池。`
```java
corePoolSize:3
maximumPoolSize:200
keepAliveTime:60s
new ArrayBlockQueue<Runnable>(200) //这是一个有界队列
```
若是咱们把queue建立成有界队列，假设corePoolSize全部线程都在繁忙的工做，这个时候仍然有大量的任务进入队列，

- [ ] 队列满了，此时怎么办？

这个时候，若是你的maximumPoolSize是比corePoolSize大的，此时线程池就会继续建立额外的线程放入线程池中，来处理这些任务。这些额外建立的线程若是处理完了一个任务也会尝试从队列中获取任务来执行。线程池总共能够建立的线程的数量就是maximumPoolSize

- [ ] 线程池的队列满了，且已经到达了线程的最大数目，会发生什么？

可是还有一种状况，若是任务很是多，额外线程所有建立完了，队列仍是满的，此时仍是有新的任务来，又该怎么办？<br />执行拒绝策略：<br />此时只能reject掉，有几种不一样的reject策略，能够传入RejectedExecutionHandler<br />（1）AbortPolicy (2)DiscardPolicy (3)DiscardOldestPolicy (4) CallerRunsPolicy (5) 自定义

若是后续慢慢没有任务了，额外建立的线程出去空闲状态，那么线程会等待最大存活时间，若是在这个时间内没有获取新的任务，它就会销毁。实际上maximumPoolSize就是起到一个缓冲的做用。

综上所述，若是定制本身的线程池，要考虑到corePoolSize的数量，队列类型，最大线程数量，拒绝策略，还有线程释放的时间。

特别补充：咱们经常使用的fixedThreadPool是无界队列,maximumPoolSize 和 corePoolSize是同样的。队列永远不会满。或者咱们采起有界对列，能够将maximumPoolSize设置的很大，来缓冲。

- [ ] 注意一下阿里规范中对线程池的使用，避免踩坑OOM。

<a name="wwnjZ"></a>
### 08.若是在线程中使用无界阻塞队列会发生什么问题？等同于问，在远程服务异常的状况下，使用无界阻塞队列，是否会致使内存异常飙升？
![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783575828-d6885ac4-9ca6-40d9-9e57-9284d9150d6d.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=ua58df8fe&margin=%5Bobject%20Object%5D&originHeight=354&originWidth=727&originalType=url&ratio=1&status=done&style=none&taskId=uc618efd5-feac-4c38-958e-42d4af9dab3)<br />调用超时，队列变的愈来愈大，此时会致使内存飙升起来，并且还可能会致使内存溢出。
<a name="oYQlR"></a>
### 09.线程池的队列满了以后，会发生什么？
经过上一个问题分析咱们发现使用无界队列可能会由于线程处理任务速度比较慢，可是有不少任务堆积致使堆内存溢出。<br />有界队列不存在堆内存溢出的问题，但一样会有它的问题。若是咱们将maximumPoolSize设置的很是大，那么当任务不少时，就会建立不少的额外线程，一台机器上，有几千个，甚至是几万个线程，每一个线程都有本身的栈内存，占用必定的内存资源，建立太多的线程会致使栈内存耗尽，可能会产生栈内存溢出。

那么若是咱们将maximumPoolSize设置的很小，又会致使额外线程也满了可是任务仍是多出队列的限制，此时就会拒绝策略，致使某些任务不可以顺利执行。

这里提供一种自定义策略的思路做为参考，咱们能够把这个任务信息持久化写入到磁盘中去，后台专门启动一个线程，后续等待线程池的工做负载下降了，能够慢慢的从磁盘中读取以前持久化的任务，从新提交到线程池中去执行。<br />综上所述，咱们在选用线程池时要综合考虑。
<a name="mRoA4"></a>
### 10.若是线上机器忽然宕机，线程池的阻塞队列中的请求怎么办？
必然会致使线程池中积压的任务都会丢失。<br />如何解决这个问题呢？<br />咱们能够在提交任务以前，在数据库中插入这个任务的信息，更新任务的状态：未提交、已提交、已完成。提交成功后，更新它的状态是已提交状态。<br />系统重启后，用一个后台线程去扫描数据库里的未提交和已提交状态的任务，能够把任务的信息读取出来，从新提交到线程池里去，继续进行执行。
<a name="XDkeT"></a>
### 11.谈谈对JAVA内存模型的理解？
read、load、use、CPU运算  ，assign、store、write <br />读	加载	   使用  CPU运算， 分配，  存储，  写入
```java
public class HelloWord(){
	private int data = 0;
	public void increment(){
		data++;
	}
}

HelloWorld helloWorld = new HelloWorld();

//线程1
new Thread(){
	public void run(){
		helloWorld.increment();
		}
	}.start();

//线程2
new Thread(){
	public void run(){
		helloWorld.increment();
		}
	}.start();

```
上面这段代码在内存中的过程以下图所示。<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633935689298-b5243852-f12a-4a1f-82bf-9caae09d124f.png#clientId=uf3a3b9d2-628b-4&from=paste&height=602&id=uc9463b0f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1204&originWidth=1812&originalType=binary&ratio=1&size=434948&status=done&style=none&taskId=u27492ec0-ed5f-4b89-ac0e-f7d10e71535&width=906)
<a name="AKI3O"></a>
### 12.说说JAVA内存模型中的原子性、有序性、可见性？
连环炮：Java内存模型 > 原子性、可见性、有序性 > volatile > happens-before/内存屏障

有可见性 就是如果有多个线程对一个数据进行操作时，如果一个线程成功修改了数据，那么其他线程能够立即更新工作内存中的该数据，即随时保持最新数据状态。这就叫有可见性，反之没有可见性。

原子性，就是当有一个线程在对内存中的某个数据进行操做的时候，必需要等这个线程彻底操做结束后，其余线程才可以操做，这就是原子性。反之就是没有原子性，多线程默认是没有原子性的，须要咱们经过各类方式来实现原子性，如同步等等。

有序性，就是代码的顺序应该和指令的顺序相同。在执行过程当中不会发生指令重排，这就是有序性，反之就是没有有序性。

<a name="pXBW8"></a>
### 13.能从JAVA底层角度聊聊volatile关键字的原理么？
内存模型 -> 原子性、可见性、有序性 -> volatile

若是直接问volatile关键字，想要解释清楚的话，要从Java内存模型开始讲起。<br />volatile关键字是用来解决可见性和有序性问题，在有些罕见的条件下，能够有限的保证原子性。<br />可是它主要不是用来保证原子性的。

- [ ] 哪些罕见情况呢？  

32位机器中，对double，long做赋值操作时，可能会出现非原子性，此时就需要用volatile关键字修饰，避免非原子性的赋值。因为这两种类型占用内存是64位，在32位机器中是分两步赋值的，不是原子性的。而在64位的机器中，就是原子性的，记住这个特例。

volatile保证可见性的原理，若是多个线程操做一个被volatile修饰的变量，当其中一个线程成功对组内存中的数据完成修改之后，它会将其余线程工做内存中的该变量的数据设为失效状态，迫使其它线程从新从主内存中读取变量数据，从而实现有可见性。

- [ ] MESI嗅探机制，如何实现其他工作线程中的数据失效？

在不少的开源中间件系统的源码里，大量的使用了volatile。经常使用的一个场景是对于一个变量，有的线程要更新它有的线程要读取它来进行判断操做，这个时候就须要使用volatile关键字，来保证读取到最新的数据。
<a name="d4bxf"></a>
### 
<a name="OqGyh"></a>
### 14. 你知道指令重排、内存栅栏以及happens-before这些是什么么？
volatile关键字和有序性的关系，volatile是如何保证有序性，从而避免发生指令重排的。
```java
boolean volatile flag = false;

//线程1：
prepare(); // 准备资源
flag = true;

//线程2：
while(!flag){
	Thread.sleep(10000);
} 
execute(); //基于准备好的资源执行操作

```
Java有一个happens-before原则：<br />编译器、指令器可能对代码重排序，乱排，要遵照必定的规则，happens-before原则，只要符合happens-before原则，那么就不能胡乱重排，若是不符合这些规则的话，那就能够本身排序。

一、程序次序规则：一个线程内，按照代码顺序，书写在前面的操做先行发生于书写在后面的操做。<br />二、锁定规则：一个unlock操做先行发生于后面对同一个锁的lock操做。<br />三、volatile变量规则：对一个volatile变量的写操做先行发生于后面对这个volatile变量的读操做。必须保证先写再读。<br />四、传递规则：若是操做A先行发生于操做B，而操做B又先行发生于操做C，那么能够得出操做A<br />先行发生于操做C。<br />五、线程启动规则：Thread对象的start()方法先行发生于此线程的每个动做。<br />六、线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断时间的发生。<br />七、线程终结规则：线程中全部的操做都先行发生于线程的终止检测，咱们能够经过Thread.join()方法结束、Thread.isAlive()的返回值手段检测现场是否已经终止执行<br />八、对象终结规则：一个对象的初始完成先行发生于他的finalize()方法的开始。

上面这8条原则的意思便是，若是程序中的代码知足上述条件，就必定会按照这个规则来保证指令的顺序。<br />总结分类就是：线程运行类，对象终结类，加锁个过程类，volatile关键字类，顺序之间的传递性类。主要是从这5个方面来保证指令顺序性问题。

注意这里有个前置条件：一个线程内，肯定是按照代码顺序执行的，但是不同线程内，可能是会指令重排的。

规则制定了一些特殊状况下，不容许编译器、指令器对咱们写的代码进行指令重排，必须保证代码的有序性。

除了上述功能外，volatile还要其余的可以预防指令重排的规定，例如volatile前面的代码必定不能指令重排到volatile变量操做的后面，它后面的代码不能指令重排获得volatile前面。

重点<br />指令重排的概念>happens-before>volatile起到避免指令重排

- [ ] 那么问题是：volatile是如何保证指令重排的呢？ 底层实现是什么？

答案在下一章节，有点复杂，看不太懂。记住几个关键字就行。<br />大概意思是，在class指令里面会添加一些，Load1，Load2, LoadStore屏障，StoreStore屏障，以此来保证CPU执行时对指令的顺序性，和内存回写的实时性。

<a name="AGiuc"></a>
### 15.volatile底层是如何基于内存屏障保证可见性和有序性的？
volatile+原子性：不可以保证原子性，只有在一些极端状况下能保证原子性。<br />保证原子性：synchronized,lock,加锁。<br />（1）lock指令：volatile保证可见性

对volatile修饰的变量，执行写操作的话，JVM会发送一条lock前缀指令给CPU，CPU在计算完之后会立即将这个值写回主内存，同时因为有MESI缓存一致性协议，所以各个CPU都会对总线进行嗅探，自己本地缓存中的数据是否被别人修改

如果发现别人修改了某个缓存的数据，那么CPU就会将自己本地缓存的数据过期掉，然后这个CPU上执行的线程在读取那个变量的时候，就会从主内存重新加载最新的数据了

lock前缀指令 + MESI缓存一致性协议

（2）内存屏障：volatile禁止指令重排序<br />volatille是如何保证有序性的？加了volatile的变量，可以保证前后的一些代码不会被指令重排，这个是如何做到的呢？指令重排是怎么回事，volatile就不会指令重排，简单介绍一下，内存屏障机制是非常非常复杂的，如果要讲解的很深入

Load1：<br />int localVar = this.variable<br />Load2：<br />int localVar = this.variable2<br />LoadLoad屏障：Load1；LoadLoad；Load2，确保Load1数据的装载先于Load2后所有装载指令，他的意思，Load1对应的代码和Load2对应的代码，是不能指令重排的

Store1：<br />this.variable = 1<br />StoreStore屏障<br />Store2：<br />this.variable2 = 2<br />StoreStore屏障：Store1；StoreStore；Store2，确保Store1的数据一定刷回主存，对其他cpu可见，先于Store2以及后续指令。<br />LoadStore屏障：Load1；LoadStore；Store2，确保Load1指令的数据装载，先于Store2以及后续指令<br />StoreLoad屏障：Store1；StoreLoad；Load2，确保Store1指令的数据一定刷回主存，对其他cpu可见，先于Load2以及后续指令的数据装载

volatile的作用是什么呢？<br />volatile variable = 1<br />this.variable = 2 => store操作<br />int localVariable = this.variable => load操作

对于volatile修改变量的读写操作，都会加入内存屏障<br />每个volatile写操作前面，加StoreStore屏障，禁止上面的普通写和他重排；每个volatile写操作后面，加StoreLoad屏障，禁止跟下面的volatile读/写重排

每个volatile读操作后面，加LoadLoad屏障，禁止下面的普通读和voaltile读重排；每个volatile读操作后面，加LoadStore屏障，禁止下面的普通写和volatile读重排

并发这块，往深了讲，synchronized、volatile，底层都对应着一套复杂的cpu级别的硬件原理，大量的内存屏障的原理；lock API，concurrenthashmap，都是各种复杂的jdk级别的源码，技术深度是很深入的。<br />[

](https://blog.csdn.net/u013073869/article/details/105271345)
<a name="Hgzix"></a>
### 16.能说说ThreadLocal的底层实现原理么？
<a name="p1x2o"></a>
## Spring
<a name="Oowoq"></a>
### 01.说说你对Spring的IOC机制的理解能够嘛？
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633937646848-eacbff04-d3df-41c8-b34d-4fb944f97125.png#clientId=uf3a3b9d2-628b-4&from=paste&height=323&id=ucccb0e70&margin=%5Bobject%20Object%5D&name=image.png&originHeight=646&originWidth=1758&originalType=binary&ratio=1&size=2330888&status=done&style=none&taskId=u51090278-bd6a-4fcd-964d-5dba041e58f&width=879)<br />**程序的耦合和解耦 IOC叫控制翻转其目的就是为了下降程序的耦合性**
```java
package com.iteima.jdbc;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;

/**
 * 程序的耦合
 *      耦合：程序间的依赖关系
 *          包括：
 *              类之间的依赖
 *              方法间的依赖
 *      解耦：
 *          降低程序间的依赖关系
 *      实际开发中：
 *          应该做到：编译期不依赖，运行时才依赖。
 *      解耦的思路：
 *          第一步：使用反射来创建对象，而避免使用new关键字。
 *          第二步：通过读取配置文件来获取要创建的对象全限定类名
 *
 */
public class JdbcDemo1 {
    public static void main(String[] args) throws  Exception{
        //1.注册驱动
//        DriverManager.registerDriver(new com.mysql.jdbc.Driver());
        Class.forName("com.mysql.jdbc.Driver");

        //2.获取连接
        Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/eesy","root","1234");
        //3.获取操作数据库的预处理对象
        PreparedStatement pstm = conn.prepareStatement("select * from account");
        //4.执行SQL，得到结果集
        ResultSet rs = pstm.executeQuery();
        //5.遍历结果集
        while(rs.next()){
            System.out.println(rs.getString("name"));
        }
        //6.释放资源
        rs.close();
        pstm.close();
        conn.close();
    }
}
```
为何咱们在进行Jdbc注册驱动的时候要使用class.forname（）目的就是将编译时期的错误转换成运行时的异常。解耦的解决方案就是将new操做用反射来实现，可是反射就要用到全限定类名来生成对象，咱们经过读取配置文件的方式来获取全限定类名，这样就能够避免在全限定类名产生变化时要修改源码。
```java
package com.itheima.factory;

import java.io.InputStream;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

/**
 * 一个创建Bean对象的工厂
 *
 * Bean：在计算机英语中，有可重用组件的含义。
 * JavaBean：用java语言编写的可重用组件。
 *      javabean >  实体类
 *
 *   它就是创建我们的service和dao对象的。
 *
 *   第一个：需要一个配置文件来配置我们的service和dao
 *           配置的内容：唯一标识=全限定类名（key=value)
 *   第二个：通过读取配置文件中配置的内容，反射创建对象
 *
 *   我的配置文件可以是xml也可以是properties
 */
public class BeanFactory {
    //定义一个Properties对象
    private static Properties props;

    //定义一个Map,用于存放我们要创建的对象。我们把它称之为容器
    private static Map<String,Object> beans;

    //使用静态代码块为Properties对象赋值
    static {
        try {
            //实例化对象
            props = new Properties();
            //获取properties文件的流对象
            InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream("bean.properties");
            props.load(in);
            实例化容器是因为如果不将创建的对象放入到容器中，那么由于垃圾回收机制就会被回收了
            //实例化容器
            beans = new HashMap<String,Object>();
            //取出配置文件中所有的Key
            Enumeration keys = props.keys();
            //遍历枚举
            while (keys.hasMoreElements()){
                //取出每个Key
                String key = keys.nextElement().toString();
                //根据key获取value
                String beanPath = props.getProperty(key);
                //反射创建对象 反射创建对象调用的是默认构造函数
                Object value = Class.forName(beanPath).newInstance();
                //把key和value存入容器中
                beans.put(key,value);
            }
        }catch(Exception e){
            throw new ExceptionInInitializerError("初始化properties失败！");
        }
    }

    /**
     * 根据bean的名称获取对象
     * @param beanName
     * @return
     */
    public static Object getBean(String beanName){
        return beans.get(beanName);
    }

    /**
     * 根据Bean的名称获取bean对象
     * @param beanName
     * @return
	此种方法创建对象是多例的 所以要读取配置文件的时候
    public static Object getBean(String beanName){
        Object bean = null;
        try {
            String beanPath = props.getProperty(beanName);
//            System.out.println(beanPath);
            bean = Class.forName(beanPath).newInstance();//每次都会调用默认构造函数创建对象
        }catch (Exception e){
            e.printStackTrace();
        }
        return bean;
    }*/
}
```
需要一个配置文件来配置咱们的bean对象，配置文件里面的信息是惟一标识和全限定类名的一一对应的关系，得到全限定类名之后经过反射的方式建立bean对象，这就是工厂模式。<br />单例可能形成成员变量的线程安全问题，可是dao,service中通常都没有成员变量，因此不用考虑线程安全问题可使用单例设计模式。<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783575674-41a0659e-3266-436d-9235-b65bfcc53186.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=uc24825f9&margin=%5Bobject%20Object%5D&originHeight=575&originWidth=769&originalType=url&ratio=1&status=done&style=none&taskId=u95067b16-ed0e-483e-b533-828d04dbe15)<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783576364-bef7e7db-8c89-4545-9fe8-d112695c2bf3.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=u6064c5e1&margin=%5Bobject%20Object%5D&originHeight=570&originWidth=706&originalType=url&ratio=1&status=done&style=none&taskId=u8eb71c42-6f01-4c17-a11b-9fc2ab527ef)<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783576309-33841c54-ae77-477e-90d2-fcfb4f5eba4c.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=u73d05fe1&margin=%5Bobject%20Object%5D&originHeight=500&originWidth=794&originalType=url&ratio=1&status=done&style=none&taskId=uac4de05f-ba5b-4054-8d7c-f8dbe4d6d29)<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783576450-e7f7f1d8-5112-4e14-8f5c-043750610549.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=u92df9c2d&margin=%5Bobject%20Object%5D&originHeight=519&originWidth=797&originalType=url&ratio=1&status=done&style=none&taskId=uf35df882-0a10-457e-ba6a-abd94366aee)<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783576594-f7c21914-4a31-48cd-9ed1-697a673b0e4e.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=u26911dff&margin=%5Bobject%20Object%5D&originHeight=379&originWidth=756&originalType=url&ratio=1&status=done&style=none&taskId=u492e064e-dd81-41d7-8b68-e1e4116166a)<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783577153-74d8cb5b-de22-4af3-8bc0-943f0d2ce660.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=u6c0b8636&margin=%5Bobject%20Object%5D&originHeight=165&originWidth=785&originalType=url&ratio=1&status=done&style=none&taskId=ub723b2ee-0e1b-4dd4-9034-71e2c9ffdd6)<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783577157-c8a3c040-2bd4-4f9e-a040-bed902552dcd.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=u80573c35&margin=%5Bobject%20Object%5D&originHeight=511&originWidth=703&originalType=url&ratio=1&status=done&style=none&taskId=u55373cb6-25cd-4fc9-b18e-5d66158bbca)<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783577143-b932cfc3-12d7-4489-a0c4-dfdb2d1a8c84.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=u9e18a6d9&margin=%5Bobject%20Object%5D&originHeight=493&originWidth=706&originalType=url&ratio=1&status=done&style=none&taskId=ua635b010-0e97-4838-a51e-7ba93b00107)<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783577262-8dff353d-2f36-4ea4-b935-c387e0cb2716.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=uf92fcf9b&margin=%5Bobject%20Object%5D&originHeight=350&originWidth=734&originalType=url&ratio=1&status=done&style=none&taskId=u62d5f862-0cda-408c-a603-a0dc1c30768)<br />还有set方法注入,实际开发中一般使用set方法注入。

- [x] Spring依赖注入（DI）的三种方式？

1.接口注入<br />2.get Set 方法注入<br />3.构造函数注入<br />另外：在XML中注入bean其本质也就是get,set函数注入。

<a name="aBGuF"></a>
### 02.说说你对spring的AOP机制的理解？
Spring 核心框架里面，最关键的两个机制，就是ioc和aop。根据xml配置或者注解，去实例化咱们全部的bean，管理bean之间的依赖注入，让类与类之间的耦合性下降，维护代码的时候更加方便轻松。

AOP是面向切面编程，简单的说就是把咱们重复的代码抽取出来，在须要执行的时候，使用动态代理技术，在不修改源码的基础上，对咱们已有的方法进行加强。<br />AOP的做用和优点<br />做用：在程序运行期间，不修改源码对已有方法进行加强。<br />优点：减小重复代码，提升开发效率，维护方便<br />AOP的实现方式：使用动态代理技术。<br />用在注解实现，以及对某个接口或者函数做切面实现，做到对业务代码的低侵入。减少耦合。

- [x] 什么是动态代理？ 什么是静态代理？（实现和细节后面再复习）
1. 代理分为静态代理和动态代理两种。
1. 静态代理，代理类需要自己编写代码写成。
1. 动态代理，代理类通过 Proxy.newInstance() 方法生成。
1. 不管是静态代理还是动态代理，代理与被代理者都要实现两样接口，它们的实质是面向接口编程。
1. 静态代理和动态代理的区别是在于要不要开发者自己定义 Proxy 类。
1. 动态代理通过 Proxy 动态生成 proxy class，但是它也指定了一个 InvocationHandler 的实现类。
1. 代理模式本质上的目的是为了增强现有代码的功能。

- [x] 了解一下动态代理的几种实现方式？

java动态代理是利用反射机制生成实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。<br />cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改字节码生成子类来处理。

- [ ] JDK动态代理和CGLIB字节码生成的区别？

（1）JDK动态代理只能对实现了接口的类生成代理，而不能针对类<br /> （2）CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，因为是继承，所以该类或方法最好不要声明成final。

<a name="tfq6x"></a>
### 03.了解过cglib动态代理吗？他跟jdk动态代理的区别是什么？
<a name="PdL1y"></a>
#### 动态的代理的特色
在不改变源码的基础上，对一个类中的方法进行加强。其特色是：字节码随用随建立，随用随加载。它与静态代理的区别也在于此。由于静态代理是字节码一上来就建立好，并完成加载。装饰者模式就是静态代理的一种体现。
<a name="B4uUe"></a>
#### 动态代理的两种实现方式
```java
package com.itheima.cglib;

/**
 * 一个生产者
 */
public class Producer implements IProducer{

    /**
     * 销售
     * @param money
     */
     @override
    public void saleProduct(float money){
        System.out.println("销售产品，并拿到钱："+money);
    }

    /**
     * 售后
     * @param money
     */
     @override
    public void afterService(float money){
        System.out.println("提供售后服务，并拿到钱："+money);
    }
}


```
<a name="RMLKb"></a>
###### 基于接口的动态代理
```java
package com.itheima.proxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * 模拟一个消费者
 */
public class Client {

    public static void main(String[] args) {
        final Producer producer = new Producer();

        /**
         * 动态代理：
         *  特点：字节码随用随创建，随用随加载
         *  作用：不修改源码的基础上对方法增强
         *  分类：
         *      基于接口的动态代理
         *      基于子类的动态代理
         *  基于接口的动态代理：
         *      涉及的类：Proxy
         *      提供者：JDK官方
         *  如何创建代理对象：
         *      使用Proxy类中的newProxyInstance方法
         *  创建代理对象的要求：
         *      被代理类最少实现一个接口，如果没有则不能使用
         *  newProxyInstance方法的参数：
         *      ClassLoader：类加载器
         *          它是用于加载代理对象字节码的。和被代理对象使用相同的类加载器。固定写法。
         *      Class[]：字节码数组
         *          它是用于让代理对象和被代理对象有相同方法。固定写法。
         *      InvocationHandler：用于提供增强的代码
         *          它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。
         *          此接口的实现类都是谁用谁写。
         */
       IProducer proxyProducer = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(),
                producer.getClass().getInterfaces(),
                new InvocationHandler() {
                    /**
                     * 作用：执行被代理对象的任何接口方法都会经过该方法
                     * 方法参数的含义
                     * @param proxy   代理对象的引用
                     * @param method  当前执行的方法
                     * @param args    当前执行方法所需的参数
                     * @return        和被代理对象方法有相同的返回值
                     * @throws Throwable
                     */
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        //提供增强的代码
                        Object returnValue = null;

                        //1.获取方法执行的参数
                        Float money = (Float)args[0];
                        //2.判断当前方法是不是销售
                        if("saleProduct".equals(method.getName())) {
                            returnValue = method.invoke(producer, money*0.8f);
                        }
                        return returnValue;
                    }
                });
        proxyProducer.saleProduct(10000f);
    }
}


```
<a name="eXjnX"></a>
###### 基于子类的动态代理
```java
package com.itheima.cglib;

import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

/**
 * 模拟一个消费者
 */
public class Client {

    public static void main(String[] args) {
        final Producer producer = new Producer();

        /**
         * 动态代理：
         *  特点：字节码随用随创建，随用随加载
         *  作用：不修改源码的基础上对方法增强
         *  分类：
         *      基于接口的动态代理
         *      基于子类的动态代理
         *  基于子类的动态代理：
         *      涉及的类：Enhancer
         *      提供者：第三方cglib库
         *  如何创建代理对象：
         *      使用Enhancer类中的create方法
         *  创建代理对象的要求：
         *      被代理类不能是最终类
         *  create方法的参数：
         *      Class：字节码
         *          它是用于指定被代理对象的字节码。
         *
         *      Callback：用于提供增强的代码
         *          它是让我们写如何代理。我们一般都是些一个该接口的实现类，通常情况下都是匿名内部类，但不是必须的。
         *          此接口的实现类都是谁用谁写。
         *          我们一般写的都是该接口的子接口实现类：MethodInterceptor
         */
        Producer cglibProducer = (Producer)Enhancer.create(producer.getClass(), new MethodInterceptor() {
            /**
             * 执行北地阿里对象的任何方法都会经过该方法
             * @param proxy
             * @param method
             * @param args
             *    以上三个参数和基于接口的动态代理中invoke方法的参数是一样的
             * @param methodProxy ：当前执行方法的代理对象
             * @return
             * @throws Throwable
             */
            @Override
            public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
                //提供增强的代码
                Object returnValue = null;

                //1.获取方法执行的参数
                Float money = (Float)args[0];
                //2.判断当前方法是不是销售
                if("saleProduct".equals(method.getName())) {
                    returnValue = method.invoke(producer, money*0.8f);
                }
                return returnValue;
            }
        });
        cglibProducer.saleProduct(12000f);
    }
}


```
<a name="D1n5z"></a>
#### 二者之间的区别
jdk动态代理是面向接口的动态代理。若是你的类是实现了某个接口，spring aop会使用jdk动态代理，生成一个和你实现一样接口的一个代理类，构造一个实例对象出来。<br />cglib动态代理是经过子类实现的动态代理。若是咱们的类没有实现接口，spring aop会改用cglib 来实现动态代理，他是生成你的类的一个子类，能够动态生成字节码，覆盖你的方法，在方法里面加入加强的方法。

<a name="p78RV"></a>
### 04.能说说Spring中的Bean是线程安全的吗？
bean的做用域以下图所示：<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783577328-105437ee-dd45-492c-9114-3fac8fae3cfa.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=u07d0aa13&margin=%5Bobject%20Object%5D&originHeight=519&originWidth=797&originalType=url&ratio=1&status=done&style=none&taskId=u83896894-479b-43b3-b65b-74446b3a894)<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783577684-93f98f69-b94d-490b-8689-f15ff96910f6.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=uefc6209b&margin=%5Bobject%20Object%5D&originHeight=470&originWidth=1136&originalType=url&ratio=1&status=done&style=none&taskId=u5ae85bb2-7e7d-4fbc-89a0-46603545b5f)<br />是线程不安全的。spring bean默认来讲是单例的，是线程不安全的。可是java web系统中，通常来讲不多在spring bean中放一些实例变量，一般都是多个组件互相调用，最终去访问数据库的，因此通常结果就是多个线程并发的访问数据库。

<a name="qS3zx"></a>
### 05.Spring的事务实现原理是什么？能聊聊你对事务传播机制的理解么？
spring ioc 和 aop ,动态代理技术，bean的线程安全问题，事务机制

事务的实现原理：若是说你加了一个@Transactional注解，此时spring就会使用AOP的思想，对你的这个方法在执行以前去开启事务，执行完毕以后，根据你方法是否报错，来决定回滚仍是提交事务。<br />事务传播机制的理解：[事务传播机制的理解](https://www.cnblogs.com/baizhanshi/p/10425467.html)<br />事务传播机制<br />比如说，我们现在有一段业务逻辑，方法A调用方法B，我希望的是如果说方法A出错了，此时仅仅回滚方法A，不能回滚方法B,必须得用REQUIRES-NEW,传播机制，让他们两的事务是不同的。<br />方法A调用方法B,如果出错，方法B只能回滚他自己，方法A可以带着方法B一起回滚，NESTED嵌套事务。

- [x] 总共有几种事务传播机制？
- **propagation_requierd**：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。（默认的）
- **propagation_supports**：支持当前事务，如果没有当前事务，就以非事务方法执行。
- **propagation_mandatory**：使用当前事务，如果没有当前事务，就抛出异常。
- **propagation_required_new**：新建事务，如果当前存在事务，把当前事务挂起。
- **propagation_not_supported**：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
- **propagation_never**：以非事务方式执行操作，如果当前事务存在则抛出异常。
- **propagation_nested**：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作

<a name="HCJ3T"></a>
### 06.能说说Spring中使用了哪些设计模式吗？
工厂模式，单例模式，代理模式<br />spring ioc 核心的设计模式的思想体现。
<a name="OXIJ1"></a>
### 07.能画一张图说一说springMvc的核心架构么？
![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783577699-4e289b9d-cd8c-48c5-9a89-4e00905f48fe.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=u5823604b&margin=%5Bobject%20Object%5D&originHeight=401&originWidth=691&originalType=url&ratio=1&status=done&style=none&taskId=ubeef4c7f-aa9e-4f9c-abdc-ebb8e1e16f6)<br />注意上图是前后端没有分离的架构，如果是前后端分离的架构，那么在第十步应该是返回一个json串，然后前端获取json串以后对页面进行渲染，然后返回html页面给浏览器。而不是放在后端中由后端来完成。

<a name="Gxmcw"></a>
## JVM
<a name="FSXyU"></a>
### 01.JVM中有哪几块内存区域？Java 8 以后对内存分代作了什么改进？
tomcat部署，tomcat本身就是基于java来开发的，咱们启动的不是本身的系统，是一个tomcat是一个jvm进程，咱们写得系统只不过是一些代码，放在tomcat的目录里，tomcat会加载咱们的代码到jvm中去。<br />JVM最经常使用的内存区域有三块 栈内存，堆内存和永久代。栈内存是线程每一个线程独享的，堆内存是共享的，永久代中存储的是类的信息。<br />java8 以后将永久代中的常量池放到了堆内存中，永久代变成了metaspace(元区域）。

<a name="auVf3"></a>
### 02.你知道JVM是如何运行起来的吗？咱们的对象是如何分配的？
<a name="xHmzD"></a>
### 03.说说JVM在哪些状况下会触发垃圾回收能够吗？
![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783577845-7f8447ed-888e-4822-b248-c82856b50dca.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=u441d3568&margin=%5Bobject%20Object%5D&originHeight=588&originWidth=1106&originalType=url&ratio=1&status=done&style=none&taskId=ud743f04a-815f-435e-a044-179f6334b5c)<br />我们的jvm的内存其实是有限制的，不可能是无限的，昂贵的资源，2核4G的机器，堆内存也就2GB左右，4核8G的机器堆内存也就4G左右，栈内存也需要空间，metaspace区域放类信息也需要空间。

jvm中有一个内存分代模型，年轻代和老年代，加在一起是堆内存，其中年轻代又分为三部分。年轻代和老年代的比例是我们可以设置的。

比如说年轻代一共是2GB内存，给老年代是2GB内存，默认情况下eden和2个s的比例是：8:1：1，eden是1.6GB, s是0.2GB

如果eden区域满了，此时必然触发垃圾回收，young gc ,ygc。谁是可以回收的垃圾对象？没有被引用的对象就是可以被回收的对象。<br />[

](https://blog.csdn.net/u013073869/article/details/105271345)
<a name="cri2G"></a>
### 04.说说JVM年轻代的垃圾回收算法？对象何时转移到老年代？
垃圾回收有一个概念，叫做stop the world，停止你的jvm里的工作线程的运行，然后扫描所有的对象，判断哪些可以回收，哪些不可以回收。<br />年轻代，大部分情况下，对象生存周期是很短的，可能0.01ms之内，线程执行了3个方法，创建了几个对象，0.01ms之后方法就都执行结束了，此时那几个对象就会在0,01ms之内变成垃圾，可以回收了。

复制算法，一次young gc,年轻代的垃圾回收。将eden中存活的对象复制到s1中，清空eden：<br />将s1和eden中存活的复制到s2中，清空eden和s1;将s2和eden存活的复制到s1中，清空eden和s2.

三种场景：<br />第一种场景，有的对象在年轻代里面熬过了很多次的垃圾回收，例如15次垃圾回收，此时会认为这个对象是要长期存活的对象。例如Spring容器中的bean对象。<br />第二种情况就是s区放不下存活的对象。<br />第三种情况就是特别大的对象。反复移动大对象消耗性能。<br />[

](https://blog.csdn.net/u013073869/article/details/105271345)
<a name="JhnXJ"></a>
### 05.说说老年代的垃圾回收算法？经常使用的垃圾回收器都有什么？

- 老年代对象愈来愈多，老年代内存空间也会满，是否是可使用相似的年轻代的复制算法？<br />答案是否认的，由于在老年代的对象中，不少都是长期引用的，spring容器管理的各类bean。
- 长期存活的对象是比较多的，可能甚至都有几百mb

对老年代而言，他里面的垃圾对象多是没有那么多的。一开始采用标记-清理的方式，找出那些垃圾对象，让后直接把垃圾对象在老年代里清理掉，这样就会产生内存 碎片的问题。<br />后来采用标记-整理的方法，把老年代里的存活对象标记出来，移动到一块儿，存活对象压缩到一片内存空间去<br />剩余的空间都是垃圾整个给清理掉，剩余的都是连续的可用的内存空间，解决了内存碎片的问题。<br />垃圾回收器、<br />parnew （新生代）+ cms（老年代）的组合， g1 直接分代回收 。g1能够实现新生代和老年代的垃圾一块儿回收。新版本，慢慢的就是主推g1垃圾回收器了，之后会淘汰掉parnews+cms组合，可是如今使用jdk8~jdk9居多，因此仍是parnew+cms组合居多。<br />cms分红好几个阶段，初始标记，并发标记，并发清理等等，老年代垃圾回收是比较慢的，通常起码比年轻代垃圾回收慢个10倍以上。因此将它拆分红几个阶段，尽量得让其和运行的其它线程并发执行。


<a name="S3afa"></a>
### 06.大家生产环境中的Tomcat是如何设置JVM参数的？如何检查JVM运行状况的？




<a name="xHey3"></a>
### 07.你在实际项目中是否作过JVM GC优化，怎么作的？



<a name="niSKH"></a>
### 08.谈谈你对java跨平台性的理解？为何java能够一次编译处处运行？
不是说java语言能够跨平台 ，而是各个不一样的平台均可以有让java语言运行的环境而已。<br />程序从源码到运行能够分为如下几个阶段，编码-编译-运行-调试。java在编译阶段体现了跨平台的特性。编译的过程大概是这样的：首先将java源码转化成class字节码文件，这是第一次编译，class字节码文件就是能够处处运行的文件。而后java字节码会被转化为目标机器的机器代码，这是由JVM来执行的，就是java的第二次编译。<br />“处处运行”的关键和前提就是JVM。由于在第二次编译的过程当中JVM起着相当重要的做用。在能够运行java虚拟机的地方都内含着一个JVM操做系统。从而实现到处处运行的效果。须要强调的是，java不是编译机制，而是解释机制。java字节码的设计充分考虑了JIT这一及时编译方式，能够将字节码直接转化成高性能的本地机器码，这一样是虚拟机的一个构成部分。

- [ ] 了解一下：一行代码的执行过程？
- [ ] <br />
<a name="x8Und"></a>
## 网络
<a name="GYl2m"></a>
### 01.你能聊一聊TCPIP四层网络模型嘛？OSI七层网络模型也要说一下！
为了统一各个电脑厂商的网络传输协议，搞出一个标准的OSI网络七层模型规范：<br />应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。<br />那么在这个基础上，又简化出了TCP/IP四层模型，数据链路层、网络层、传输层、应用层。
<a name="J6DD8"></a>
#### 物理层
**（数据传输的方式，电信号，010101。）**<br />网线，海底电缆等都属于网络的物理层，在物质层面将两台电脑链接起来，而后传递0/1的电路信号。
<a name="CY83a"></a>
#### 数据链路层
（**通过以太网封装成数据包，规定所有传输都得经过网卡，每个网卡有个MAC地址，通过广播方式，告诉局域网内的所有机器，让他们去验证接收MAC地址是否和自己的MAC地址一样）**<br />数据链路层，物理层给各个电脑连接起来了，还传输最底层的0和1电路信号，关键不行啊，你得定义清楚哪些0和1分为一组，这些信号啥意思？这才能进行通信。所以数据链路层就干这事儿，定义一下电路信号咋分组。<br />00000011（从电脑1出发，要到电脑2去）<br />00101（从电脑1出发，要到电脑3去）<br />0101（从电脑2触发，要到电脑4去）<br />01（从电脑3出发，要到电脑5去）

很多年前，每个公司都定义自己的电路信号分组方式，但是后来出来了以太网协议，以太网。一组电信号是一个数据包，叫一个帧（frame），每个帧分成两个部分，标头（head）和数（data），标头包含一些说明性的东西，比如说发送者、接收者和数据类型之类的。

每台电脑要往另外一台电脑发送数据，一堆0/1电路信号，封装成数据包，包含头和数据，头里包含了从哪儿来到哪儿去，必须从一台电脑的一个网卡，发送到另外一个电脑的一个网卡，所以以太网发送的数据包必须得指定，目标电脑的网卡的mac地址。

以太网规定了，每个网卡必须得包含一个mac地址，mac地址就是这个网卡的唯一标识，

以太网协议规定了，接入网络里的所有设备，都得有个网卡，以太网协议里的那个数据包，在数据链路层传输的数据包，必须从一个电脑的网卡传输到另外一个电脑的网卡，而这个网卡地址就叫做所谓的mac地址。每块网卡出厂的时候，就有一个唯一的mac地址，48位的二进制，但是一般用12个16进制数字表示，前6个16进制是厂商编号，后6个16进制是网卡流水号。

windows上，ipconfig /all，看看物理地址，就是mac地址，7C-67-A2-20-AB-5C

所以在以太网里传输数据包的时候，必须指定接收者的mac地址才能传输数据。

但是以太网的数据包怎么从一个mac地址发送到另一个mac地址？这个不是精准推送的，以太网里面，如果一个电脑发个数据包出去，会广播给局域网内的所有电脑设备的网卡 ，然后每台电脑都从数据包里获取接收者的mac地址，跟自己的mac地址对比一下，如果一样，就说明这是发给自己的数据包。

但是上面这种广播的方式，仅仅针对一个子网（局域网）内的电脑，会广播，否则一个电脑不能广播数据包给全世界所有的其他电脑吧，是仅仅广播给一个子网里面的电脑的。<br />[

](https://blog.csdn.net/u013073869/article/details/105271345)<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783577860-b8d21a4a-a65e-4a41-93ac-516064a86cd7.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=V9yEK&margin=%5Bobject%20Object%5D&originHeight=424&originWidth=1136&originalType=url&ratio=1&status=done&style=none&taskId=uafeabaa8-f394-415a-b9f2-a1cf3d3a013)<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633944183025-004e77e2-aa6f-4527-a3dc-1409c6d735e7.png#clientId=uf3a3b9d2-628b-4&from=paste&height=299&id=u3b151333&margin=%5Bobject%20Object%5D&name=image.png&originHeight=246&originWidth=615&originalType=binary&ratio=1&size=175968&status=done&style=none&taskId=u1793e059-0a51-442d-99d2-b9978819662&width=748.5)
<a name="XKDnR"></a>
#### 网络层
**（通过IP，区分计算机是否在一个网关内）**<br />上面说到，子网内的电脑，通过以太网发个数据包，对局域网内的电脑，是广播出去的。那么怎么知道哪些电脑在一个子网内呢？这就得靠网络层了，这里就有一套IP地址，IP地址就可以让我们区分哪些电脑是一个子网的。

网络层里有IP协议，IP协议定义的地址就叫做IP地址。IP地址有IPv4和IPv6两个版本，目前广泛使用的是IPv4，是32个二进制数字组成的，但是一般用4个十进制数字表示，范围从0.0.0.0到255.255.255.255之间。

每台计算机，都会分配一个ip地址，ip地址的前24位（就是前面3个十进制数字），代表了网络，后8位（就是最后1个十进制数字），代表了主机。

如果几台电脑是一个子网的，那么前面的3个十进制数字一定是一样的。举个例子，大家平时做实验，玩儿虚拟机吧，自己win上开几个linux虚拟机，你会发现，win上的ip地址可能是192.168.0.103，然后几个虚拟机的ip地址是192.168.0.182，192.168.0.125，192.168.0.106，类似这样的。

这个win机器和几个虚拟机，前面3个十进制数字都是192.168.0，就代表大家是一个子网内的，最后那个数字是这个子网的不同主机的编号。

但是实际上上面就是举个例子，其实单单从ip地址是看不出来哪些机器是一个子网的，因为从10进制是判断不出来的。需要通过ip地址的二进制来判断，结合一个概念来判断，叫做子网掩码。

比如说ip地址是192.168.56.1，子网掩码是255.255.255.0。知道了子网掩码之后，如果要判断两个ip地址是不是一个子网的，就分别把两个ip地址和自己的子网掩码进行二进制的与运算，与运算之后，比较一下代表网络的那部分。

192.168.56.1和192.168.32.7，判断是不是一个子网的，拿子网掩码255.255.255.0，跟两个ip地址的二进制做与运算<br />11000000.10101000.00111000.00000001<br />11111111.11111111.11111111.00000000

子网掩码的二进制是：11111111.11111111.11111111.00000000，然后就跟ip地址的二进制做与好了，通过二进制来比较网络部分的地址是不是一模一样的。

有了网络层的ip地址之后，两台在子网内的电脑终于可以通过广播+mac地址判断来传输数据包进行通信了。

但是如果发现要接受数据包的计算机不在子网内，那么就不能通过广播来发送数据包，需要通过路由来发送数据包。

看到路由，就想到了路由器了，对了，路由器大家都熟悉吧，自己平时也会去买对吧，比如小米的路由器啥的，家里上网一般都会弄个路由器对吧，ok。路由器负责将多个子网进行连接，因为比如你在自己家里，其实你就只是你自己的一个子网，你要是访问网站啥的，是跟那个网站机器所在的子网进行通信。

每个电脑都可以搞多个网卡的，不是只有一个网卡，一般笔记本电脑都有以太网网卡和wifi网卡，发送数据包的时候要决定走哪个网卡。路由器，其实就是配置了多个网卡的一个专用设备，可以通过不同的网卡接入不同的网络。

家里的路由器是包含了交换机和路由的两个功能的，如果是连接到局域网内的设备就把线插LAN那儿；如果是连接到英特网，就把线插在WAN那儿。

这儿给大家举个例子，就是两个局域网之间，如果要是通过一个路由器进行通信的话，是怎么弄的。

大概过程就是，路由器配置了两块网卡，每个网卡可以连到一个局域网内。

局域网1内的电脑，要发送数据包到局域网2内的电脑，在数据包里写上自己的ip地址和对方的ip地址。但是他们俩不在一个局域网内，于是局域网1内的电脑，先通过交换机将数据包发送给路由器，这个过程需要将路由器的一块网卡的ip地址对应的mac地址写到数据包的头部，然后才能通过交换机广播出去，路由器接收到之后比较自己一块网卡的mac地址，就知道是来找自己的。

接着路由器接收到数据包之后，就会在局域网2内，将目标机器的ip地址对应的mac地址写入头部，接着再次通过交换机发送广播通知，发送给局域网2内的电脑。

一个局域网内的每台机器都有自己的ARP cache，这个ARP就是用来在一个局域网内让各个设备都知道每个设备的ip地址和mac地址的对应关系的，一般就是某个机器发送广播通知自己的ip地址和mac地址的对应关系，然后每个机器给他一个回应。以此类推，大家都互相这样广播一把，ip地址和mac地址的对应关系，大家不就都知道了吗？

所以大家在上面可以看到，一个子网内的机器之间通信，就是在数据包里写上对方的mac地址，然后交换机广播出去ok了；但是如果是跨子网的通信，就是写上对方的ip地址和路由器的mac地址，然后先通过mac地址广播到路由器，让路由器再根据另外一个子网的ip地址转换为mac地址，通过另外一个子网的交换机广播过去。就这个意思。<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633944817629-be7d8c97-ccb8-4570-a0fd-3c863e3be82e.png#clientId=uf3a3b9d2-628b-4&from=paste&height=295&id=uc8a26c7d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=245&originWidth=618&originalType=binary&ratio=1&size=175898&status=done&style=none&taskId=u86104ac5-f966-470e-b04d-96c86e0dd9e&width=743.991455078125)<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633944820616-58e75407-d8de-43b9-8d91-6b9ab28cf040.png#clientId=uf3a3b9d2-628b-4&from=paste&height=516&id=u809326f2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=407&originWidth=593&originalType=binary&ratio=1&size=41946&status=done&style=none&taskId=u0c74515a-587b-4a7c-85d6-ead17b52ce6&width=752.491455078125)

下面介绍几个概念：

- 网关其实就是路由器的一种，运作在网络层。可以把路由器上的ip地址认为就是网关，路由器上每个网卡都有mac地址和对应的ip地址。路由器虽然有mac地址，但是不能通过mac地址寻址的，必须通过ip地址寻址，所以路由器其实是工作在网络层的设备。（电脑上有默认网关）

- 网络交换机是通过mac地址来寻址和传输数据包的；但是路由器是通过ip地址寻址和传输数据包的。网络交换机主要用在局域网的通信，一般你架设一个局域网，里面的电脑通信是通过数据链路层发送数据包，通过mac地址来广播的，广播的时候就是通过网络交换机这个设备来把数据广播到局域网内的其他机器上去的；路由器一般用来让你连入英特网。。

- LAN，就是local area network，就是局域网；

WAN，就是wide area network，就是广域网。<br />WLAN是wireless local area network，是无线局域网，也就是wifi，在局域网内，直接通过wifi无线联网。

假设你访问百度网站，先经过mac地址和交换机广播到默认网关，而后进行一层一层网关在寻址，一直到找到百度所在的那个服务器的ip地址和对应的mac地址（这里也用到交换机在子网的广播），而后传输数据。

<a name="ktOwh"></a>
#### 传输层
上面我们大概明白了通过网络层的ip地址怎么划分出来一个一个的子网，然后在子网内部怎么通过mac地址广播通信；跨子网的时候，怎么通过ip地址 -> mac地址 -> 交换机 -> 路由器 -> ip地址 -> mac地址 -> 交换机的方式来通过路由器进行通信。

但是这里还有一个问题，就是一台机器上，是很多个程序用一个网卡进行网络通信的，比如说浏览器、QQ、视频直播，这些软件都用了一个网卡往外面发送数据，然后从网卡接收数据，对吧。

所以还需要一个端口号的概念，就是你得发送数据包到某个机器的一个网卡的某个端口上去，然后那个机器上监听那个端口的程序，就可以提取发送到这个端口的数据，知道是自己的数据。端口号是065536的范围内，01023被系统占用了，别的应用程序就用1024以上的端口就ok了。

电脑1，是在端口48362监听的，通过网卡发送了一条数据 -> 电脑2的ip地址的20386这个端口 -> 电脑2的上面的某个QQ，监听着20386的端口 -> 电脑2的网卡接收到一条数据之后，发现人家找的是20386这个端口，就去找谁哪个哥儿们在监听20386端口，QQ在监听，我就把这个网卡过来的数据，传递给QQ，通过端口知道，哪条数据是给你的

所以其实大家会发现一点，网络层，是基于ip协议，进行主机和主机间的寻址和通信的，然后传输层，其实是建立某个主机的某个端口，到另外一个主机的某个端口的连接和通信的。

这个通信，就是通过socket来实现的，通过socket就可以基于tcp/ip协议完成刚才上面说的一系列的比如基于ip地址和mac地址转换和寻址啊，通过路由器通信啊之类的，而且会建立一个端口到另外一个端口的连接。

udp和tcp都是传输层的协议，作用就是在数据包里加入端口号，可以通过端口号进行点对点的通信了。udp协议是不可靠的，发出去人家收到没有就不知道了；tcp协议是可靠的，要求三次握手，而且要求人家接收到数据必须回复你。

传输层的tcp协议，仅仅只是规定了一套基于端口的点对点的通信协议，包括如何建立连接，如何发送和读取消息，但是实际上如果你要基于tcp协议来开发，你一般是用socket，java socket网络编程。

<a name="ulBa3"></a>
#### 应用层
通过传输层的tcp协议可以传输数据，但是人家收到数据之后，怎么来解释？比如说收到个邮件你怎么处理？收到个网页你怎么处理？类似这个意思，所以针对各种不同的应用，邮件、网页之类的，都是定义不同的应用层协议的。这个应用层，我们就假设综合了会话层、表示层和应用层了，3层合成1层。

电脑1走tcp协议发送了一段东西过来，发送到电脑2的20386端口<br />GET [http://localhost:8080/](http://localhost:8080/) http/1.1<br />key:valuel<br />key:value

电脑2走tcp协议读取到了属于自己这个20386端口 的一段数据<br />GET [http://localhost:8080/](http://localhost:8080/) http/1.1<br />key:valuel<br />key:value<br />发送了一段响应<br />200<br />key;value<br />key:value

又通过底层的tcp发了出去，电脑1的30987端口，ip<br />电脑1，网卡，走以太网协议收到一个数据包<br />200<br />key;value<br />key:value


比较常见的，应用层的协议就是http协议，进行网络通讯。<br />4层：数据链路层（以太网协议） ，网络层（ip协议），传输层（tcp协议 ），应用层（http协议）<br />7层：物理层，会话层，表示层和会话层合并成应用层。

然后我们看下自己的网络设置，一般包含了ip地址、子网掩码、网关地址、DNS地址。前面3个我们其实都知道啥意思了。ip地址和子网掩码用来划分子网的，判断哪些ip地址在一个子网内。同时你的ip地址和mac地址关联起来的，唯一定位了你的网卡。网关地址，你就认为是路由器上的那个网卡的ip地址吧，路由器的网卡也有mac地址，mac地址对应了一个ip地址。

那么DNS是什么呢？咱们通常是经过ip地址+mac地址+端口号来定位一个通讯目标的，可是若是浏览器上输入一个www.baidu.com？这个时候是先把www.baidu.com发给DNS服务器，而后DNS服务器告诉你对应的ip地址。



<a name="JFeE3"></a>
### 02.浏览器请求www.baidu.com的全过程大概是怎么样的？
<a name="xZYie"></a>
#### 宏观
1、客户端浏览器通过DNS解析到www.baidu.com的IP地址202.108.22.5，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到202.108.22.5，然后通过TCP进行封装数据包，输入到网络层。

2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。 (建立tcp连接)

3、客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。 （IP的重要功能是寻址和路由）

4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。（IP地址转为MAC）

**事件顺序**

1. 由域名→IP 地址
1. 寻找 IP 地址的过程依次经过了浏览器缓存、系统缓存、hosts文件、路由器缓存、 递归搜索根域名服务器。
1. 建立 TCP/IP 连接（三次握手具体过程）
1. 由浏览器发送一个 HTTP 请求
1. 经过路由器的转发，通过服务器的防火墙，该 HTTP 请求到达了服务器（下面的过程其实就是这一步）
1. 服务器处理该 HTTP 请求，返回一个 HTML 文件
1. 浏览器解析该 HTML 文件，并且显示在浏览器端

**需要注意：**<br />o HTTP 协议是一种基于 TCP/IP 的应用层协议，进行 HTTP 数据请求必须先建立 TCP/IP 连接<br />o 可以这样理解：HTTP 是轿车，提供封装或显示数据的具体形式；Socket 是发动机，提供了网络通信的能力。<br />o 两个计算机之间的交流无非是两个端口之间的数据通信 , 具体的数据会以什么样的形式展现是以不同的应用层协议来定义的。

参考链接：浏览器输入一个网址（www.baidu.com）后执行的全过程<br />[https://blog.csdn.net/u014590757/article/details/80035410?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.edu_weight&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.edu_weight](https://blog.csdn.net/u014590757/article/details/80035410?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.edu_weight&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.edu_weight)

Http1.1版本之后，底层就是简历的TCP长连接，避免每次请求都要去简历TCP的连接，消耗性能。
<a name="nrFvV"></a>
#### 微观
首先应该知道网络七层模型大概都是怎么回事了，然后四层模型其实就是会话层、表示层和应用层，合并为了一个应用层，同时没把物理层算在内。

并且我们也大概知道每一层的协议和作用，网络通信的时候都是怎么回事了，现在我们来看看假设通过浏览器发送一个请求，你访问到那个网站对应的机器，然后人家再给你一个响应的全过程。<br />现在我们先假设，我们给电脑设置了几个东西：<br />ip地址：192.168.31.37<br />子网掩码：255.255.255.0<br />网关地址：192.168.31.1<br />DNS地址：8.8.8.8

这时，我们打开一个浏览器，请求www.baidu.com地址，这个时候找DNS服务器，DNS服务器解析域名之后，返回一个ip地址，比如172.194.26.108。<br />接着会判断两个ip地址是不是一个子网的，用子网掩码255.255.255.0，对两个ip地址做与运算，拿到192.168.31.0和172.194.26.0，明显不是一个子网的。<br />如图：<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633945789532-2bd541d2-0d1b-4f9a-a111-7758cf391892.png#clientId=uf3a3b9d2-628b-4&from=paste&height=199&id=u6e8f63e0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=398&originWidth=484&originalType=binary&ratio=1&size=130815&status=done&style=none&taskId=u60697310-b889-4cd4-a70e-a021d032433&width=242)<br />那就得发送一个数据包给网关，其实你就认为是我们的路由器吧，就是192.168.31.1，而且我们是可以拿到网关ip地址的mac地址的，现在我们从应用层出发，通过浏览器访问一个网站，是走应用层的http协议的，并且要把浏览器发出的请求打包成数据包，要把哪些东西给放到数据包中去呢？

先介绍一下http协议 ：<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633945799455-9c83993b-d4be-4c69-962c-cd0ef7b36781.png#clientId=uf3a3b9d2-628b-4&from=paste&height=300&id=u9aedb805&margin=%5Bobject%20Object%5D&name=image.png&originHeight=366&originWidth=795&originalType=binary&ratio=1&size=64794&status=done&style=none&taskId=u7fb0032b-3f91-4b59-ac5f-802f8f384cd&width=652.5)<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633945804826-5912b169-8c69-4d04-ad62-bac3371c4aa2.png#clientId=uf3a3b9d2-628b-4&from=paste&height=649&id=u24084834&margin=%5Bobject%20Object%5D&name=image.png&originHeight=697&originWidth=721&originalType=binary&ratio=1&size=133474&status=done&style=none&taskId=u828e31fd-29f8-469d-b189-d6ea58ffe02&width=671.4971313476562)<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633945815887-32615444-bcce-41a1-a6e4-6eb44424956a.png#clientId=uf3a3b9d2-628b-4&from=paste&height=302&id=u5f7fb080&margin=%5Bobject%20Object%5D&name=image.png&originHeight=329&originWidth=736&originalType=binary&ratio=1&size=75253&status=done&style=none&taskId=ue2aceb90-6bea-496f-a933-901b3fe7c96&width=674.9971313476562)<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633945820909-5fa36a0d-fce7-4f69-b397-b24024f44e18.png#clientId=uf3a3b9d2-628b-4&from=paste&height=594&id=uadd53b16&margin=%5Bobject%20Object%5D&name=image.png&originHeight=530&originWidth=605&originalType=binary&ratio=1&size=119906&status=done&style=none&taskId=ua8d07989-ba39-43bb-b825-4d465ecef57&width=677.5)<br />这就构成了一个http请求报文浏览器请求一个地址，先按照应用层的http协议，封装一个应用层数据包，数据包里就放了http请求报文，这个时候会将这个http请求报文打包成一个数据包，仅仅只是数据包的数据部分，此时是数据包是没有头的。上面根据http协议搞一个http请求报文，然后搞一个数据包出来，就是网络模型中到的应用层干的事儿了。

接着就是跑传输层来了，这个层是tcp协议，这个tcp协议会让你设置端口，发送方的端口随机选一个，接收方的端口一般是默认的80端口。

这个时候，会把应用层数据包给封装到tcp数据包中去，而且会加一个tcp头，这个tcp数据包是对应一个tcp头的，这个tcp头里就放了端口号信息。<br />如图：<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633945836025-21c9393b-8c79-4cfd-9aee-a7acdf610262.png#clientId=uf3a3b9d2-628b-4&from=paste&height=129&id=u45e55c26&margin=%5Bobject%20Object%5D&name=image.png&originHeight=180&originWidth=536&originalType=binary&ratio=1&size=77734&status=done&style=none&taskId=u8b5e9e5e-09a4-48dd-a863-9be96b7e05f&width=382.9971618652344)<br />接着跑到网络层来了，走ip协议，这个时候会把tcp头和tcp数据包，放到ip数据包里去，然后再搞一个ip头，ip头里本机和目标机器的ip地址。

这里本机ip地址是192.168.31.37，

目标机器是172.194.26.108。

因为，通过ip协议，可以判断说，两个ip地址不是在一个子网内的，所以此时只能将数据包先通过以太网协议广播到网关上去，通过网关再给他发送出去，如图：<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633945855992-5a6aff6d-e1de-49bc-bac2-475acfde7443.png#clientId=uf3a3b9d2-628b-4&from=paste&height=129&id=u1d9ddde1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=188&originWidth=697&originalType=binary&ratio=1&size=125384&status=done&style=none&taskId=ue3a371d0-293e-4ee3-989f-09c139593a7&width=477.4942932128906)<br />接着是数据链路层，这块走以太网协议，这里是把ip头和ip数据包封到以太网数据包里去，然后再加一个以太网数据包的头，头里放了本机网卡mac地址，和网关的mac地址。但是以太网数据包的限制是1500个字节，但是假设这个时候ip数据包都5000个字节了，那么需要将ip数据包切割一下。

这个时候一个以太网数据包要切割为4个数据包，每个数据包包含了以太网头、ip头和切割后的ip数据包，4个数据包的大小分别是1500，1500,1500，560。ip头里包含了每个数据包的序号。<br />如图：<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633945872233-fe2d812f-4d62-41ed-b1ce-89ca26cf9091.png#clientId=uf3a3b9d2-628b-4&from=paste&height=515&id=u4ff71ab7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=419&originWidth=613&originalType=url&ratio=1&size=102636&status=done&style=none&taskId=ueeb9d988-b7c0-48ad-9985-a52014b81e0&width=753.9971313476562)<br />这4个以太网数据包都会通过交换机发到你的网关上，然后你的路由器是可以联通别的子网的，这个是时候你的路由器就会转发到别的子网的可能也是某个路由器里去，然后以此类推吧，N多个路由器或者你叫网关也行，N多个网关转发之后，就会跑到百度的某台服务器，接收到4个以太网数据包。

百度服务器接收到4个以太网数据包以后，根据ip头的序号，把4个以太网数据包里的ip数据包给拼起来，就还原成一个完整的ip数据包了。接着就从ip数据包里面拿出来tcp数据包，再从tcp数据包里取出来http数据包，读取出来http数据包里的各种协议内容，接着就是做一些处理，然后再把响应结果封装成http响应报文，封装在http数据包里，再一样的过程，封装tcp数据包，封装ip数据包，封装以太网数据包，接着通过网关给发回去。

如下图：<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633945886546-b9603f1b-6723-4b86-957c-da7c45120552.png#clientId=uf3a3b9d2-628b-4&from=paste&height=327&id=u763231d1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=290&originWidth=714&originalType=url&ratio=1&size=33133&status=done&style=none&taskId=u00bbd686-c3a5-422a-92de-381749f5dc0&width=805.9971313476562)<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783578373-665103cc-9fa9-46b3-9e01-caa83867643f.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=u51152711&margin=%5Bobject%20Object%5D&originHeight=540&originWidth=1006&originalType=url&ratio=1&status=done&style=none&taskId=u5e097768-dcbe-4943-966f-b5d4f68d5e4)<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783578430-a2d34a88-da99-461b-b321-5b07d7f46fab.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=u81decd78&margin=%5Bobject%20Object%5D&originHeight=540&originWidth=1128&originalType=url&ratio=1&status=done&style=none&taskId=ua1c5ee62-c750-439d-9010-a12c2dab7fc)



<a name="PNcAy"></a>
### 03.TCP三次握手和四次挥手的流程图？为啥不是两次或者五次呢？
附上一个讲的很好的链接：[两张动图-彻底明白TCP的三次握手与四次挥手](https://blog.csdn.net/qzcsu/article/details/72861891)<br />[https://blog.csdn.net/qzcsu/article/details/72861891](https://blog.csdn.net/qzcsu/article/details/72861891)

首先我们来回顾一下 TCP 的数据传输单元，TCP 传送的数据单元称为报文段。一个 TCP 报文段分为 TCP 首部和 TCP 数据两部分，整个 TCP 报文段都封装在 IP 数据报中的数据部分，TCP 首部长度是4的整数倍，其中有固定的20个字节，剩余的可变动的就是选项和填充「最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。」，20个固定的字节包括了源端口号（2 字节）、目的端（2字节）、seq序列号（4字节）、确认号ack（4字节）、以及确认位ACK 等等。

确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；<br />同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；<br />终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；<br />其次，我们来详细讲解一下三次握手、四次挥手的过程：
<a name="UHlkb"></a>
#### 三次握手
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633953582023-f0f13313-f7d9-4129-aabf-58a26f6762f4.png#clientId=uf3a3b9d2-628b-4&from=paste&height=264&id=u336f8862&margin=%5Bobject%20Object%5D&name=image.png&originHeight=527&originWidth=1115&originalType=binary&ratio=1&size=44446&status=done&style=none&taskId=u325e4568-ef8a-44c5-9e84-64daa6a366c&width=557.5)<br />首先，在三次握手建立连接的阶段，是不会传输 TCP 报文段的，传输的是 传输控制块（TCB），传输控制块 TCB(Transmission Control Block)存储了每一个连接中的一些重要信息，如：TCP 连接表，指向发送和接收缓存的指针，指向重传队列的指针，当前的发送和接收序号等等。

**收到报文，发送报文，同时修改自身的状态，如果不发送报文，自身状态也不会改变**<br />	**最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。**

1. TCP服务器进程先创建传输控制块TCB时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；
1. TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。
1. TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。
1. TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。
1. 当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。

[<br />](https://blog.csdn.net/u013073869/article/details/105271345)1.**为何不直接在第一次握手就带上报文段消息，非要第三次才可以带？**<br />因为 TCP 是要保证数据的不丢失且可靠，如果在第一次就带上报文段消息，此次建立连接很有可能就会失败，那么就不能保证数据的不丢失了，在不可靠的机制上进行这种操作，换来的代价太大，每次发送报文段的资源也会增大，得不偿失；<br />而第三次握手的时候，客户端已经知道服务器端准备好了，所以只要告诉服务器端自己准备好了就okay了，所以此时带上报文段信息没有任何问题。<br />[

](https://blog.csdn.net/u013073869/article/details/105271345)<br />2.**可不可以只握手两次？**<br />一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。<br />肯定是不可以的，三次握手主要是解决这样一个常见的问题，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。<br />简而言之就是避免服务端长时间等待。<br />如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。
<a name="Ai3Sg"></a>
#### ![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783578547-c35eee7a-53a9-45fd-be6f-9096af130140.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=ud2f4de0b&margin=%5Bobject%20Object%5D&originHeight=540&originWidth=1127&originalType=url&ratio=1&status=done&style=none&taskId=u56f86463-9bee-4877-b4cd-206a4bb6225)<br />四次挥手
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633954161515-83b8e047-e838-4dbb-b1f7-aac5829efa42.png#clientId=u60afa8ee-640f-4&from=paste&height=442&id=u91722e22&margin=%5Bobject%20Object%5D&name=image.png&originHeight=684&originWidth=1066&originalType=binary&ratio=1&size=62082&status=done&style=none&taskId=u6f8d10bd-5be7-4ad9-83d0-36623089a2d&width=688.9971313476562)
> 数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。

1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
1. 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。**TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，**也就是整个CLOSE-WAIT状态持续的时间。
1. 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文**（在这之前还需要接受服务器发送的最后的数据）**。
1. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了**LAST-ACK（最后确认）**状态，等待客户端的确认。
1. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
1. 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

[

](https://blog.csdn.net/u013073869/article/details/105271345)<br />**一个很常见的问题，为何不能三次挥手呢？**
> - 首先如果去掉最后一次挥手，那么服务器端就不知道自己要关闭的报文有没有传输成功，可能半路上就失败了，但是此时客户端不知道，导致客户端一直在等待服务器关闭，但是此时服务器端直接就关闭了；
> - 如果中间的两次挥手合并，那是肯定不行的，因为此时服务器端可能还有很多报文未处理完，此时直接关闭肯定会对传输有很大影响。
> - <br />

**为什么客户端在收到 服务器端发来的 FIN 包后要等 2 个最长报文段传输时间？**
> 防止最后自己发去的 ack 没传送到服务器，如果服务器没收到客户端的 ack，肯定会选择重发一次 FIN 包，那么此时如果客户端已经关闭了，客户端就不能再发 ack 确认收到了，至于为何是 2 个报文段传输时间，因为刚好一去一回嘛… 2 个最长报文传输时间没有 FIN 包发来，就说明服务器已经关闭了，客户端也就可以安心关闭了。
> 

**如果已经建立了连接，但是客户端突然出现故障了怎么办？**
> TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。


<a name="KCKfy"></a>
### 04.说一下http的工做流程？http1.0,http1.1,http2.0具体有哪些区别？
其实就是说一说http请求和响应的规范。<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633955050586-7498b48f-48d2-4d73-8166-4ad2ea3f9633.png#clientId=u60afa8ee-640f-4&from=paste&height=278&id=ube79d1df&margin=%5Bobject%20Object%5D&name=image.png&originHeight=366&originWidth=795&originalType=binary&ratio=1&size=64794&status=done&style=none&taskId=ua86b882e-b236-44aa-aba9-a0cb7cb71f5&width=604.491455078125)<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633955056704-736adca4-70d6-4c2d-89b7-f4c75f571965.png#clientId=u60afa8ee-640f-4&from=paste&height=630&id=uc4102f70&margin=%5Bobject%20Object%5D&name=image.png&originHeight=697&originWidth=721&originalType=binary&ratio=1&size=133474&status=done&style=none&taskId=u59cb5603-6f54-4096-9b8a-8b39847ec0e&width=651.4943237304688)<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633955063948-2eb569c0-1c5f-474c-a08a-d74d741aac08.png#clientId=u60afa8ee-640f-4&from=paste&height=276&id=u7bab9bde&margin=%5Bobject%20Object%5D&name=image.png&originHeight=329&originWidth=736&originalType=binary&ratio=1&size=75253&status=done&style=none&taskId=u5aacb5f8-a46d-47a2-ad9c-9542e6c1bb4&width=616.9971313476562)<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633955068656-4fcf6aef-067a-461d-a6d4-1a92664fd314.png#clientId=u60afa8ee-640f-4&from=paste&height=546&id=u61478535&margin=%5Bobject%20Object%5D&name=image.png&originHeight=530&originWidth=605&originalType=binary&ratio=1&size=119906&status=done&style=none&taskId=u1d9ad2a5-a90b-4730-a631-249947becb4&width=623.4999694824219)<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633955073364-86e0fc3e-e829-4478-aa4d-fa302a82ffdd.png#clientId=u60afa8ee-640f-4&from=paste&height=398&id=ua31e7267&margin=%5Bobject%20Object%5D&name=image.png&originHeight=537&originWidth=537&originalType=binary&ratio=1&size=47462&status=done&style=none&taskId=u48d3e931-888a-4f4e-9a54-e2fc76a2cab&width=398.49432373046875)<br />http 1.0要指定keep-alive来开启持久连接，默认是短连接，就是浏览器每次请求都要重新建立一次tcp连接，完事儿了就释放tcp连接。早期的网页都很low，没啥东西，就一点文字，就用这个没问题。但是现在，一个网页打开之后，还要加载大量的图片、css、js，这就坑爹了，发送多次请求。

早期，2000年之前，那个时候网页，都很low，当时你打开一个网页，就是说现场底层tcp三次握手，跟网站建立一个tcp连接，然后通过这个tcp连接，发送一次http请求，网站返回一个http响应（网页的html，里面有一大段文字），浏览器收到html渲染成网页，浏览器就走tcp四次挥手，跟网站断开连接了

到了后面，发现2000之后，2010之后更不用说了，网页发展很迅猛，一个网页包含着大量的css、js、图片等资源。比如你请求一个网页，这个网页的html先过来，过来之后，浏览器再次发起大量的请求去加载css、js、图片，打开一个网页可能浏览器要对网站服务器发送几十次请求。

http 1.0，疯了，刚开始请求网页的html，tcp三次握手建立连接 -> 请求/响应 -> tcp四次挥手断开连接，接着再次要加载css、js、图片，要发送30个请求，上面的过程来30次，30次频繁的建立tcp连接以及释放tcp连接。很慢很慢。<br />其实最慢的不是发送请求和获取响应，打开和释放连接，这都是很重的过程

**http 1.1默认支持长连接，就是说，浏览器打开一个网页之后，底层的tcp连接就保持着，不会立马断开，之后加载css、js之类的请求，都会基于这个tcp连接来走。**http 1.1还支持host头，也就可以支持虚拟主机；而且对断点续传有支持。

浏览器，第一次请求去一个网站的一个页面的时候，就会打开一个tcp连接，接着就在一段时间内都不关闭了，然后接下来这个网页加载css、js、图片大量的请求全部走同一个tcp连接，频繁的发送请求获取响应，最后过了一段时间，这些事儿都完了，然后才会去释放那一个tcp连接。大幅度的提升复杂网页的打开的速度，性能。

http 2.0，支持多路复用，基于一个tcp连接并行发送多个请求以及接收响应，解决了http 1.1对同一时间同一个域名的请求有限制的问题。二进制分帧，将传输数据拆分为更小的帧（数据包），frame（数据包，帧），提高了性能，实现低延迟高吞吐。<br />[

](https://blog.csdn.net/u013073869/article/details/105271345)

<a name="JQnfX"></a>
### 05.聊聊https的工做原理？为啥用https就能够加密通讯？
附上两个解析链接：<br />[HTTP原理详解](http://liuduo.me/2018/05/14/https-detail/) :http://liuduo.me/2018/05/14/https-detail/<br />[深入理解HTTPS工作原理](https://segmentfault.com/a/1190000018992153#item-2)：[https://segmentfault.com/a/1190000018992153#item-2](https://segmentfault.com/a/1190000018992153#item-2)

http协议都是明文的，是没有加密的，所以其实现在一般大部分应用都是用https协议的。<br />之前是基于SSL协议对http进行加密，后来又升级到了TSL协议来加密，现在称之为SSL / TSL吧。

<a name="bI1oO"></a>
#### HTTP 的不足之处
> 通信内容使用明文——内容可能被窃听
> 不验证通信方的身份——可能遭遇伪装
> 无法验证报文的完整性——报文有可能已遭篡改
> HTTPS = HTTP + 加密 + 认证 + 数字签名 解决上述的三个问题

注意：秘钥如果没用在路径上传递，只是保存在服务器和客户端上是没有安全问题的，因为黑客都是从通信的路径上截获消息，然后破解的。如果不在路径上发送，就会是安全的。

<a name="LrHPO"></a>
#### https的工作原理大概是这样的：
（1）浏览器把自己支持的加密规则发送给网站

（2）网站从这套加密规则里选出来一套加密算法和hash算法，然后把自己的身份信息用证书的方式发回给浏览器，证书里有网站地址、加密公钥、证书颁发机构（hash算法用来保证验证消息是否没有被篡改，专业术语叫做 数字签名）

（3）浏览器验证证书的合法性，然后浏览器地址栏上会出现一把小锁；浏览器接着生成一串随机数密码，然后用证书里的公钥进行加密，这块走的非对称加密；用约定好的hash算法生成握手消息的hash值，然后用密码对消息进行加密，然后把所有东西都发给网站，这块走的是对称加密。这里的总的消息分成三部分，用公钥加密的随机密码，消息的hash值，和用随机密码加密的消息

（4）网站，从消息里面可以取出来公钥加密后的随机密码，用本地的私钥对消息解密取出来密码，然后用密码解密浏览器发来的握手消息，计算消息的hash值，并验证与浏览器发送过来的hash值是否一致，最后用密码加密一段握手消息，发给浏览器

（5）浏览器解密握手消息，然后计算消息的hash值，如果跟网站发来的hash一样，握手就结束，之后所有的数据都会由之前浏览器生成的随机密码，然后用对称加密来进行进行加密。

常用的非对称加密是RSA算法，对称加密是AES、RC4等，hash算法就是MD5

非对称加密，有个人说我加密的时候是用了一个公钥去加密，然后你解密的时候是用私钥去解密；我加密的时候用的算法，跟解密的时候用的算法，是一样的，对称加密。<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633955169669-a4747ea5-1c45-4fb5-91a1-c1276b164e48.png#clientId=u60afa8ee-640f-4&from=paste&height=500&id=u9040e074&margin=%5Bobject%20Object%5D&name=image.png&originHeight=614&originWidth=900&originalType=binary&ratio=1&size=136619&status=done&style=none&taskId=u30ee959a-3681-4f64-a0fe-9fd13198873&width=732.9885864257812)



<a name="j4rER"></a>
### 06.什么是长链接？http长链接是什么？
http本身没什么所谓的长连接短连接之说，其实说白了都是http下层的tcp连接是长连接还是短连接，tcp连接保持长连接，那么多个http请求和响应都可以通过一个链接来走。其实http 1.1之后，默认都是走长连接了，就是底层都是一个网页一个tcp连接，一个网页的所有图片、css、js的资源加载，都走底层一个tcp连接，来多次http请求即可。<br />http 1.0的时候，底层的tcp是短连接，一个网页发起的请求，每个请求都是先tcp三次握手，然后发送请求，获取响应，然后tcp四次挥手断开连接；每个请求，都会先连接再断开。短连接，建立连接之后，发送个请求，直接连接就给断开了<br />http 1.1后，tcp长连接，tcp三次握手，建立了连接，无论有多少次请求都是走一个tcp连接的，走了n多次请求之后，然后tcp连接被释放掉了。

- [ ] 那到底过多久之后才会释放掉这个TCP呢？

- [ ] 那到底是一个网址对应一个TCP，还是一个浏览器进程对应一个TCP长连接呢？[

](https://blog.csdn.net/u013073869/article/details/105271345)
<a name="aFfGG"></a>
### 07.聊聊Socket的工作原理？Socket跟TCP IP之间是啥关系？
<a name="vF0GG"></a>
#### 1、面试题
说说socket通信的原理？

<a name="dUVDW"></a>
#### 2、面试官心里分析
其实不知道大家发现没有，网络相关的问题，都是围绕着所谓的七层模型，或者是四层模型去走的。聊完四层模型，接着就是一次请求的全过程，紧接着就是聊传输层的tcp的连接，然后就是传输层的tcp协议之上的socket编程，接下来还会聊聊应用层的http协议。

<a name="VAnKX"></a>
#### 3、面试题剖析
其实说白了，socket就是在传输层里把tcp/ip协议给封装了一下，我们程序员一般都是面向socket来编程的，比如java原生就支持socket网络编程的。socket套接字。

大体来说这个步骤，就是我们搞一个ServerSocket无限等待别人来连接你，然后某个机器要跟你连接，就在本地创建一个socket去连接你，然后建立连接之后，在服务器上，ServerSocket也会创建出来一个socket的。通过客户端的socket跟服务端的socket进行通信，我给你写数据，你读数据，你给我写数据，我读数据，就这个过程。

当然这个底层，比如建立连接和释放连接，都是基于tcp三次握手和四次挥手的规范来搞的，包括基于tcp协议传输数据，其实就跟我们之前说的一样，都是封装个tcp数据包，里面有tcp报头，整了端口号啥的，然后封装在ip数据包里，最后封在以太网数据包里传递。<br />Socket相当于网络传输之间的发动机。
<a name="RfDCO"></a>
#### 4、截图如下
![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633956127987-79b374ef-386b-4ef2-82b3-f3dc387bfb96.png#clientId=u60afa8ee-640f-4&from=paste&height=379&id=u9b42176a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=523&originWidth=1025&originalType=binary&ratio=1&size=62568&status=done&style=none&taskId=ua741d34e-fbcb-40ca-b921-cfbb49e2b47&width=743.5)

- [ ] 什么是Scoket套接字？底层是怎没实现的？


[

](https://blog.csdn.net/u013073869/article/details/105271345)
<a name="Hg6GJ"></a>
### 08.进程间通信？线程间切换？
1、面试题<br />进程间是如何通信的？线程间又如何切换呢？

2、面试官心里分析<br />这个问题不是高频基础问题，但是确实可能有人会问，因为怎么说呢，计算机基础，就这点儿东西，网络、cpu、磁盘、内存、进程，所以可能有人会看看你的基础知识咋样，所以问问你这个问题。

3、面试题剖析<br />进程间的通信有很多种方式，比如说：**管道（pipe）**、**命名管道（fifo）**、**消息队列**，**共享内存**（System V）

<a name="V3aEQ"></a>
#### （1）管道（pipe）
通信管道，必须是父子进程copy过去才能有联系。否则只能用命名管道。

- unix操作系统里面，有一个fork操作，可以创建进程的子进程，或者说是复制一个进程完全一样的子进程，共享代码空间，但是各自有独立的数据空间，不过子进程的数据空间是拷贝父进程的数据空间的。
- 管道机制要求的是**两个进程之间是有血缘关系的，**就比如fork出来的父子进程。!!! 
- linux操作系统里，管道用来缓存要在进程间传输的数据，管道是一个固定大小的缓冲区，是**4kb**。管道中的数据一旦被读取出来，就不在管道里了。

- 但是如果管道满了，那么写管道的操作就阻塞了，直到别人读了管道的数据；反之如果管道是空的，那么读操作就阻塞了。就这个意思。管道一边连着一个进程的输出，一边连着一个进程的输入，然后就一个进程写数据，另外一个进程读数据，两个进程都没了，管道也就没了。管道是半双工的，就是数据只能流向一个方向，比如说你架设一个管道，只能一个进程写，另外一个进程读。

- linux里面对管道的实现，是用了两个文件，指向了一个VFS（虚拟文件系统）的索引节点inode，然后VFS索引节点指向一个物理页面，接着一个进程通过自己关联的那个文件写数据，另外一个进程通过自己关联的那个文件读数据。

<a name="vytl2"></a>
#### （2）命名管道（fifo）
管道的通信，要求必须是父子关系的进程间通信，就受到了限制，所以可以用命名管理来解决这个问题。

可以简单理解为：就相当于内部命令了一个文件，作为管道，去传输数据。

之前的管道，是没有名字的，所以必须是有父子关系的进程才能使用。但是这个命名管道是有名字的。这个命名管道，相当于是一个有名字的文件，是有路径的，所以没有血缘关系的进程多可以通过这个命名管道来通信，名字在文件系统上，数据在内存里。其他的跟管道一样，一个进程写，一个进程读，也是半双工的，数据只能单向流动。

<a name="ApLcK"></a>
#### （3）消息队列
linux的消息队列可以认为是个链表结构，linux内核有一个msgque链表，这个链表里每个指针指向一个msgid_ds结构，这个结构就描述了一个消息队列。然后进程之间就通过这个消息队列通信就可以，一样是写入数据和消费数据。消息队列的好处就是对每个消息可以指定类型，消费的时候就消费指定类型的消息就行了，功能更多一些。这种方式其实用的不多的。<br />可以简单理解为：Linux内核维护了一个LinkedList链表结构，每个指针指向一个msg节点,相当于一个消息队列，可供多个进程之间通信。<br />为啥不用数组呢？？？？？

<a name="DUr4l"></a>
#### （4）共享内存
一块物理内存被映射到两个进程的进程地址空间，所以进程之间互相都可以立即看到对方在共享内存里做出的修改，但是因为是共享内存，所以需要锁来保证同步。这个说对了很复杂，我在这里就不多说了，我觉得如果被人问到这个问题，短期内突击的话，回答到这个程度就行了，就是知道有哪些方式。如果你要深入理解各种机制，那是要好好学习linux的各种东西了。

<a name="D28K2"></a>
#### 线程间如何切换
一个进程的多个线程间切换的时候就涉及到了上下文切换，这个东西说复杂了就很复杂，但是简单来说，就是有一个时间片算法，cpu给每个线程一个时间片来执行，时间片结束之后，就保存这个线程的状态，然后切换到下一个线程去执行，这就是所谓多线程并发执行的原理，就是多个线程来回来去切换，每个线程就一个时间片里执行。太复杂的我也不讲了，大家就记住一个线程上下文切换指的是什么就行了。<br />[

](https://blog.csdn.net/u013073869/article/details/105271345)


<a name="SE0iu"></a>
## 数据库
<a name="NsIlG"></a>
### 01.MySQL MylSAM 和 InnoDB存储引擎的区别是啥？
**myisam**<br />不支持事务，不支持外键约束，索引文件和数据文件分开，这样在内存中能够缓存更多的索引，对查询的性能会更好，适用于少许的插入，大量查询的场景。<br />**innodb**<br />innodb是如今最经常使用的存储引擎，是mysql5.5以后的默认存储引擎。主要特色就是支持事务，走聚簇索引，强制要求有主键，支持外键约束，高并发、大数据量、高可用等相关成熟的数据库架构，分库分表、读写分离、主备切换，所有均可以基于innodb存储引擎来实现。到这里就能够展开来讲一说是怎么支撑大数据的，怎么进行读写分离的。<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783578837-1e09adaf-7f8f-4d76-9753-f561e0423c58.jpeg#clientId=uf6950fa8-95d1-4&from=paste&height=525&id=ua275a412&margin=%5Bobject%20Object%5D&originHeight=419&originWidth=698&originalType=url&ratio=1&status=done&style=none&taskId=u2f4d6b24-801a-4db8-bf69-c6f9f6521c6&width=874.9971313476562)<br />	主从同步的实现：首先主服务器将数据的变化记录到BinaryLog中，接下来从服务器会开启一个线程将主服务器中的数据操做同步到本身的RelayLog中，而后在开启一个线程执行该操做，更新从服务器中的数据。



<a name="my7bI"></a>
### 02.MySQL索引的原理和数据结构能介绍一下么？b+树和b-树有什么区别？MySQL聚簇索引和非聚簇索引的区别是什么？他们分别是如何存储的？使用MySQL索引都有哪些原则？MySQL复合索引如何使用？
<a name="Ny2XK"></a>
#### 网友总结
> b+树， b+树只有叶子节点上有数据
> myisam 最大的特色就是数据文件和索引文件是分开的，会先在索引文件里搜索，获得一个物理地址，而后再到数据文件中定位一个行的。
> innodb存储索引的实现，跟myisam最大的区别在于，innodb数据文件自己就是一个索引文件，key就是主键，叶子节点的data就是那个数据行。<br />innodb存储引擎，要求必需要有主键，能够默认内置的就会根据主键创建一个索引，叫作聚簇索引。<br />若是对某个非主键的字段建立一个索引，那么最后那个叶子节点的data就是主键的值，由于能够用主键的值到聚簇索引里根据主键再次查找到数据。
> 因此这里就明白了一个道理，为何innodb下不要用UUID生成的1超长字符串做为主键？由于这样会致使全部的索引的data都是那个主键值，最终致使索引会变的很大，浪费不少的磁盘空间。
> 还有一个注意事项，通常innodb表里面，建议使用统一的auto_increment自增值做为主键值，由于这样能够保持聚簇索引直接加记录就行，若是用那种不是单调递增的主键值，可能会致使b+树分裂后从新组织，浪费时间。
> 索引的使用规则<br />最左前缀匹配规则，这个东西是和联合索引相关联的，不少时候不是一个一个字段分别搞一个一个的索引，而是针对几个索引创建一个联合索引。了解记住最左前缀匹配规则。
> 索引的缺点以及注意事项<br />	索引是有缺点的，好比常见的就是会增长磁盘消耗，由于要占用磁盘空间。同时高并发的时候频繁插入和修改索引，就会致使性能的损耗。建议尽可能少建立索引，好比一个表一两个索引。


关于B+树的数据结构这里推荐一篇文章：B[+树](https://time.geekbang.org/column/article/77830)：[https://time.geekbang.org/column/article/77830](https://time.geekbang.org/column/article/77830)<br />这里给一个简单的总结，至于为什么要这样实现，m的取值要多大，B+树是如何衍生出来的参照上面的文章：

- 每个节点中子节点的个数不能超过 m，也不能小于 m/2；
- 根节点的子节点个数可以不超过 m/2，这是一个例外；
- m 叉树只存储索引，并不真正存储数据，这个有点儿类似跳表；
- 通过链表将叶子节点串联在一起，这样可以方便按区间查找；
- 一般情况，根节点会被存储在内存中，其他节点存储在磁盘中。

[

](https://blog.csdn.net/u013073869/article/details/105271345)
<a name="jqn8Q"></a>
#### 2.1 索引的数据结构是什么
其实就是让你聊聊mysql的索引底层是什么数据结构实现的，弄不好现场还会让你画一画索引的数据结构，然后会问问你mysql索引的常见使用原则，弄不好还会拿个SQL来问你，就这SQL建个索引一般咋建？

至于索引是啥？这个问题太基础了，大家都知道，mysql的索引说白了就是用一个数据结构组织某一列的数据，然后如果你要根据那一列的数据查询的时候，就可以不用全表扫描，只要根据那个特定的数据结构去找到那一列的值，然后找到对应的行的物理地址即可。

那么回答面试官的一个问题，mysql的索引是怎么实现的？<br />答案是，不是二叉树，也不是一颗乱七八糟的树，而是一颗b+树。这个很多人都会这么回答，然后面试官一定会追问，那么你能聊聊b+树吗？

但是说b+树之前，咱们还是先来聊聊b-树是啥，从数据结构的角度来看，b-树要满足下面的条件：<br />（1）d为大于1的一个正整数，称为B-Tree的度。<br />（2）h为一个正整数，称为B-Tree的高度。<br />（3）每个非叶子节点由n-1个key和n个指针组成，其中d<=n<=2d。<br />（4）每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。<br />（5）所有叶节点具有相同的深度，等于树高h。<br />（6）key和指针互相间隔，节点两端是指针。<br />（7）一个节点中的key从左到右非递减排列。<br />（8）所有节点组成树结构。<br />（9）每个指针要么为null，要么指向另外一个节点。<br />（10）如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于v(key1)，其中v(key1)为node的第一个key的值。<br />（11）如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于v(keym)，其中v(keym)为node的最后一个key的值。<br />（12）如果某个指针在节点node的左右相邻key分别是keyi和keyi+1且不为null，则其指向节点的所有key小于v(keyi+1)且大于v(keyi)。

上面那段规则，我也是从网上找的，说实话，没几个java程序员能耐心去看明白或者是背下来，大概知道是个树就好了。就拿个网上的图给大家示范一下吧：

比如说我们现在有一张表：<br />(id int，name varchar，age int)

我们现在对id建个索引：15、56、77、20、49<br />select * from table where id = 49<br />select * from table where id = 15<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633958054311-d94d917d-33a9-49f7-a4dd-11c2f729fea6.png#clientId=u60afa8ee-640f-4&from=paste&height=153&id=u98971be3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=150&originWidth=515&originalType=binary&ratio=1&size=9768&status=done&style=none&taskId=u8504e093-97ca-4665-bcf2-5e9b740ab5c&width=524.5)<br />反正大概就长上面那个样子，查找的时候，就是从根节点开始二分查找。左边叶子节点小于右边的叶子结点。大概就知道这个是事儿就好了，深讲里面的数学问题和算法问题，时间根本不够，面试官也没指望你去讲里面的数学和算法问题，因为我估计他自己也不一定能记住。

好了，b-树就说到这里，直接看下一个，b+树。b+树是b-树的变种，啥叫变种？<br />就是说一些原则上不太一样了，稍微有点变化，同样的一套数据，放b-树和b+树看着排列不太一样的。<br />而mysql里面一般就是b+树来实现索引，所以b+树很重要。

**b+树跟b-树不太一样的地方在于：**

- 每个节点的指针上限为2d而不是2d+1。
- 内节点不存储data，只存储key；
- 叶子节点不存储指针。

这图我就不自己画了，网上弄个图给大家瞅一眼：<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633958073029-7aa14d1b-9e37-432b-af93-81ee51d66bd0.png#clientId=u60afa8ee-640f-4&from=paste&height=246&id=u009dd1c2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=226&originWidth=554&originalType=binary&ratio=1&size=24110&status=done&style=none&taskId=u89ace36e-dc81-4397-9321-0959ac601f8&width=601.9886169433594)<br />select * from table where id = 15<br />select * from table where id>=18 and id<=49

但是一般数据库的索引都对b+树进行了优化，**加了顺序访问的指针**，如网上弄的一个图，这样在查找范围的时候，就很方便，比如查找18~49之间的数据：<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633958093838-d765a9bc-952b-4053-8809-6f9b0a15ffdc.png#clientId=u60afa8ee-640f-4&from=paste&height=218&id=ue7086627&margin=%5Bobject%20Object%5D&name=image.png&originHeight=198&originWidth=554&originalType=binary&ratio=1&size=24433&status=done&style=none&taskId=u4b3a7bee-92cd-4695-a08c-27cc3306f94&width=609.9886169433594)<br />其实到这里，你就差不多了，你自己仔细看看上面两个图，b-树和b+树都现场画一下，然后给说说区别，和通过b+树查找的原理即可。<br />接着来聊点稍微高级点的，因为上面说的只不过都是最基础和通用的b-树和b+树罢了，但是mysql里不同的存储引擎对索引的实现是不同的。

<a name="JNd4w"></a>
#### 2.2 myism存储引擎的索引实现
底层也是二叉树！！<br />先来看看myisam存储引擎的索引实现。就拿上面那个图，咱们来现场手画一下这个myisam存储的索引实现，在myisam存储引擎的索引中，每个叶子节点的data存放的是数据行的物理地址，比如0x07之类的东西，然后我们可以画一个数据表出来，一行一行的，每行对应一个物理地址。

**索引文件**<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633958129069-e658ac0b-bb80-45e1-8b84-d188c24ae996.png#clientId=u60afa8ee-640f-4&from=paste&height=217&id=u907ed8c1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=198&originWidth=554&originalType=binary&ratio=1&size=24433&status=done&style=none&taskId=u07932c15-208d-4cd1-8232-5cf18c0ac5e&width=607.9886169433594)<br />id=15，data：0x07，0a89，数据行的物理地址<br />数据文件单独放一个文件<br />![](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633958141167-265d09da-2c36-485f-8784-b0c02f805c2a.png#clientId=u60afa8ee-640f-4&from=paste&id=ub5d1f533&margin=%5Bobject%20Object%5D&originHeight=98&originWidth=426&originalType=url&ratio=1&status=done&style=none&taskId=u6c475c3e-4425-47f4-8d5f-d1363da9a89)<br />select * from table where id = 15 -> 0x07物理地址 -> 15，张三，22

**myisam最大的特点**<br />是数据文件和索引文件是分开的，大家看到了么，先是索引文件里搜索，然后到数据文件里定位一个行的。


<a name="TM9nZ"></a>
#### 2.3 innodb存储引擎的索引
好了，再来看看innodb存储引擎的索引实现，跟myisam最大的区别在于说，innodb的数据文件本身就是个索引文件，就是主键key，然后叶子节点的data就是那个数据的所在行。我们还是用上面那个索引起来现场手画一下这个索引好了，给大家来感受一下。<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633958153352-48e1e2e3-69dd-4647-bcb6-55c8dfecec0f.png#clientId=u60afa8ee-640f-4&from=paste&height=249&id=u3282334a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=198&originWidth=554&originalType=binary&ratio=1&size=24433&status=done&style=none&taskId=u498dc288-160a-4a01-9202-97a790acb8e&width=696.9886169433594)

innodb存储引擎，要求必须有主键，会根据主键建立一个默认索引，叫做聚簇索引，innodb的数据文件本身同时也是个索引文件，索引存储结构大致如下：<br />15，data：完整的一行数据，（15,张三,22）<br />22，data：完整的一行数据，（22,李四,30）

就是因为这个原因，innodb表是要求必须有主键的，但是myisam表不要求必须有主键。<br />另外一个是，innodb存储引擎下，如果对某个非主键的字段创建个索引，那么最后那个叶子节点的值就是主键的值，因为可以用主键的值到聚簇索引里根据主键值再次查找到数据，即所谓的回表，<br />例如：select * from table where name = ‘张三’

先到name的索引里去找，找到张三对应的叶子节点，叶子节点的data就是那一行的主键，id=15，然后再根据id=15，到数据文件里面的聚簇索引（根据主键组织的索引）根据id=15去定位出来id=15这一行的完整的数据

所以这里就明白了一个道理，为啥innodb下不要用UUID生成的超长字符串作为主键？因为这么玩儿会导致所有的索引的data都是那个主键值，最终导致索引会变得过大，浪费很多磁盘空间。

还有一个道理，一般innodb表里，建议统一用auto_increment自增值作为主键值，因为这样可以保持聚簇索引直接加记录就可以，如果用那种不是单调递增的主键值，可能会导致b+树分裂后重新组织，会浪费时间。

<a name="WAg6a"></a>
#### 2.4 索引的使用规则
一般来说跳槽时候，索引这块必问，b+树索引的结构，一般是怎么存放的，出个题，针对这个SQL，索引应该怎么来建立<br />select * from table where a=1 and b=2 and c=3，你知道不知道，你要怎么建立索引，才可以确保这个SQL使用索引来查询

好了，各位同学，聊到这里，你应该知道具体的myisam和innodb索引的区别了，同时也知道什么是聚簇索引了，现场手画画，应该都ok了。然后我们再来说几个最最基本的使用索引的基本规则。

其实最基本的，作为一个java码农，你得知道最左前缀匹配原则，这个东西是跟联合索引（复合索引）相关联的，就是说，你很多时候不是对一个一个的字段分别搞一个一个的索引，而是针对几个索引建立一个联合索引的。

给大家举个例子，你如果要对一个商品表按照店铺、商品、创建时间三个维度来查询，那么就可以创建一个联合索引：shop_id、product_id、gmt_create<br />一般来说，你有一个表（product）：shop_id、product_id、gmt_create，你的SQL语句要根据这3个字段来查询，所以你一般来说不是就建立3个索引，一般来说会针对平时要查询的几个字段，建立一个联合索引<br />后面在java系统里写的SQL，都必须符合最左前缀匹配原则，确保你所有的sql都可以使用上这个联合索引，通过索引来查询
> create index (shop_id,product_id,gmt_create)


**（1）全列匹配**<br />这个就是说，你的一个sql里，正好where条件里就用了这3个字段，那么就一定可以用到这个联合索引的：<br />select * from product where shop_id=1 and product_id=1 and gmt_create=’2018-01-01 10:00:00’

**（2）最左前缀匹配**<br />这个就是说，如果你的sql里，正好就用到了联合索引最左边的一个或者几个列表，那么也可以用上这个索引，在索引里查找的时候就用最左边的几个列就行了：<br />select * from product where shop_id=1 and product_id=1，这个是没问题的，可以用上这个索引的

**（3）最左前缀匹配了，但是中间某个值没匹配**<br />这个是说，如果你的sql里，就用了联合索引的第一个列和第三个列，那么会按照第一个列值在索引里找，找完以后对结果集扫描一遍根据第三个列来过滤，第三个列是不走索引去搜索的，就是有一个额外的过滤的工作，但是还能用到索引，所以也还好，例如：<br />select * from product where shop_id=1 and gmt_create=’2018-01-01 10:00:00’<br />就是先根据shop_id=1在索引里找，找到比如100行记录，然后对这100行记录再次扫描一遍，过滤出来gmt_create=’2018-01-01 10:00:00’的行

这个我们在线上系统经常遇到这种情况，就是根据联合索引的前一两个列按索引查，然后后面跟一堆复杂的条件，还有函数啥的，但是只要对索引查找结果过滤就好了，根据线上实践，单表几百万数据量的时候，性能也还不错的，简单SQL也就几ms，复杂SQL也就几百ms。可以接受的。

**（4）没有最左前缀匹配**<br />那就不行了，那就在搞笑了，一定不会用索引，所以这个错误千万别犯<br />select * from product where product_id=1，这个肯定不行

**（5）前缀匹配**<br />这个就是说，如果你不是等值的，比如=，>=，<=的操作，而是like操作，那么必须要是like ‘XX%’这种才可以用上索引，比如说<br />select * from product where shop_id=1 and product_id=1 and gmt_create like ‘2018%’

**（6）范围列匹配**<br />如果你是范围查询，比如>=，<=，between操作，你只能是符合最左前缀的规则才可以范围，范围之后的列就不用索引了<br />select * from product where shop_id>=1 and product_id=1<br />这里就在联合索引中根据shop_id来查询了

**（7）包含函数**<br />如果你对某个列用了函数，比如substring之类的东西，那么那一列不用索引<br />select * from product where shop_id=1 and 函数(product_id) = 2<br />上面就根据shop_id在联合索引中查询。

<a name="SRpuu"></a>
#### 2.5 索引的缺点以及使用注意
索引是有缺点的，比如常见的就是会增加磁盘消耗，因为要占用磁盘文件，同时高并发的时候**频繁插入和修改**索引，会导致性能损耗的。

我们给的建议，尽量创建少的索引，比如说一个表一两个索引，两三个索引，十来个，20个索引，高并发场景下还可以。<br />字段，status，100行，status就2个值，0和1<br />你觉得你建立索引还有意义吗？几乎跟全表扫描都差不多了<br />select * from table where status=1，相当于是把100行里的50行都扫一遍

你有个id字段，每个id都不太一样，建立个索引，这个时候其实用索引效果就很好，你比如为了定位到某个id的行，其实通过索引二分查找，可以大大减少要扫描的数据量，性能是非常好的

在创建索引的时候，要注意一个选择性的问题，就是要选择区分度高的列，作为索引。这样效果才好。。

还有一种特殊的索引叫做前缀索引，就是说，某个字段是字符串，很长，如果你要建立索引，最好就对这个字符串的前缀来创建，比如前10个字符这样子，要用前多少位的字符串创建前缀索引，就对不同长度的前缀看看选择性就好了，一般前缀长度越长选择性的值越高。

**（降低开发成本）**<br />大家要明白，SQL达到95%都是单表增删改查，如果你有一些join等逻辑，就放在java代码里来做。SQL越简单，后续迁移分库分表、读写分离的时候，成本越低，几乎都不用怎么改造SQL。

我这里给大家说下，互联网公司而言，

- 用MySQL当最牛的在线即时的存储，存数据，简单的取出来；
- 不要用MySQL来计算，不要写join、子查询、函数放MySQL里来计算，高并发场景下；
- 计算放java内存里，通过写java代码来做；可以合理利用mysql的事务支持。

[

](https://blog.csdn.net/u013073869/article/details/105271345)



<a name="qw75i"></a>
### 03.说说事务的几个特性是什么？有哪几种隔离级别？
<a name="Z2Xtu"></a>
#### 面试题

- 事务的几个特点是什么？
- 数据库事务有哪些隔离级别？
- MySQL的默认隔离级别？
<a name="zmHJK"></a>
#### 面试官心里分析
三个基本面，存储引擎，索引，事务（了解事务的隔离级别，基于spring的事务支持）
<a name="cJbMi"></a>
#### 
<a name="PRkem"></a>
#### 什么是事务
事务就是一个并发控制单位，包含多个步骤的操做被事务所管理，要么同时成功，要么同时失败。
<a name="EGxJg"></a>
#### 事务中的四大特性？ACID

1. 原子性：是不可分割的最小操做单位，要么同时成功，要么同时失败。
1. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。
1. 隔离性：多个事务在跑的时候不能相互干扰，不能事务A操做数据，尚未结束，事务B又来修改这个数据，致使事务A的操做出错了。
1. 一致性：事务操做先后，数据变化总量不变。

<a name="lRxjK"></a>
#### 不考虑隔离会产生的三个问题？
1，脏读<br />脏读是指在一个事务处理过程里读取了另外一个未提交的事务中的数据。<br />当一个事务正在屡次修改某个数据，而在这个事务中这屡次的修改都还未提交，这时一个并发的事务来访问该数据，就会形成两个事务获得的数据不一致。例如：用户A向用户B转帐100元，对应SQL命令以下<br />update account set money=money+100 where name=’B’; (此时A通知B) update account set money=money - 100 where name=’A’;<br />当只执行第一条SQL时，A通知B查看帐户，B发现确实钱已到帐（此时即发生了脏读），而以后不管第二条SQL是否执行，只要该事务不提交，则全部操做都将回滚，那么当B之后再次查看帐户时就会发现钱其实并无转。<br />2，不可重复读<br />不可重复读是指在对于数据库中的某个数据，一个事务范围内屡次查询却返回了不一样的数据值，这是因为在查询间隔，被另外一个事务修改并提交了。<br />例如事务T1在读取某一数据，而事务T2立马修改了这个数据而且提交事务给数据库，事务T1再次读取该数据就获得了不一样的结果，发送了不可重复读。<br />不可重复读和脏读的区别是，脏读是某一事务读取了另外一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。<br />在某些状况下，不可重复读并非问题，好比咱们屡次查询某个数据固然以最后查询获得的结果为主。但在另外一些状况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不一样，A和B就可能打起来了……<br />3，虚读(幻读)<br />幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中全部的行的某个数据项作了从“1”修改成“2”的操做，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值仍是为“1”而且提交给数据库。而操做事务T1的用户若是再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉同样，这就是发生了幻读。<br />幻读和不可重复读都是读取了另外一条已经提交的事务（这点就脏读不一样），所不一样的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据总体（好比数据的个数）。
<a name="bplV3"></a>
#### 解决上述问题的方案？
设置不一样的隔离级别就能解决上述问题。<br />隔离级别：（必须得知道）

1. read uncommitted：读未提交 产生的问题：脏读、不可重复读、幻读
1. read committed：读已提交 （Oracle） 产生的问题：不可重复读、幻读
1. repeatable read：可重复读 （MySQL默认） 产生的问题：幻读
1. serializable：串行化 能够解决全部的问题<br />注意：隔离级别从小到大安全性愈来愈高，可是效率愈来愈低<br />数据库查询隔离级别：select @@tx_isolation;<br />数据库设置隔离级别：set global transaction isolation level 级别字符串;

**MVCC 多版本并发控制的机制，mysql实现不可重复读。须要了解（不记得了就看视频）**（须要熟知）
<a name="ZxXDG"></a>
##### 
<a name="xzteF"></a>
##### 3.2 事务隔离级别
1）读未提交，Read Uncommitted：这个很坑爹，就是说某个事务还没提交的时候，修改的数据，就让别的事务给读到了，这就恶心了，很容易导致出错的。这个也叫做脏读。

（2）读已提交，Read Committed（不可重复读）：这个比上面那个稍微好一点，但是一样比较尴尬<br />就是说事务A在跑的时候， 先查询了一个数据是值1，然后过了段时间，事务B把那个数据给修改了一下还提交了，此时事务A再次查询这个数据就成了值2了，这是读了人家事务提交的数据啊，所以是读已提交。<br />这个也叫做不可重复读，就是所谓的一个事务内对一个数据两次读，可能会读到不一样的值。如图：<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633960469525-83545084-e3dd-4b6b-943b-55e1f9a2e14a.png#clientId=u60afa8ee-640f-4&from=paste&height=315&id=u5035fa9a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=300&originWidth=553&originalType=binary&ratio=1&size=23184&status=done&style=none&taskId=u07c754a7-3a37-4d10-ac00-e17c051701c&width=580.491455078125)<br />（3）可重复读，Read Repeatable：这个比上面那个再好点儿，就是说事务A在执行过程中，对某个数据的值，无论读多少次都是值1；哪怕这个过程中事务B修改了数据的值还提交了，但是事务A读到的还是自己事务开始时这个数据的值。如图：<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633960463810-c0a5c812-69d1-4b09-8a4c-8221f31fba27.png#clientId=u60afa8ee-640f-4&from=paste&height=334&id=u98c38e4d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=300&originWidth=553&originalType=binary&ratio=1&size=23242&status=done&style=none&taskId=u5f3c4659-f4f3-4b9e-884e-59cc9989415&width=615.491455078125)<br />（4）幻读：不可重复读和可重复读都是针对两个事务同时对某条数据在修改，但是幻读针对的是插入<br />比如某个事务把所有行的某个字段都修改为了2，结果另外一个事务插入了一条数据，那个字段的值是1，然后就尴尬了。第一个事务会突然发现多出来一条数据，那个数据的字段是1。

那么幻读会带来啥问题呢？因为在此隔离级别下，例如：事务1要插入一条数据，我先查询一下有没有相同的数据，但是这时事务2添加了这条数据，这就会导致事务1插入失败，并且它就算再一次查询，也无法查询到与其插入相冲突的数据，同时自身死活都插入不了，这就不是尴尬，而是囧了。

（5）串行化：如果要解决幻读，就需要使用串行化级别的隔离级别，所有事务都串行起来，不允许多个事务并行操作。如图：<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633960509971-1608bef0-91db-4a21-a0d1-3aa620acb098.png#clientId=u60afa8ee-640f-4&from=paste&height=348&id=uc40c81c6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=302&originWidth=554&originalType=binary&ratio=1&size=26351&status=done&style=none&taskId=uaee9550d-a123-4368-bdd1-fdbfbcdfe8c&width=638.9886169433594)

> **MySQL的默认隔离级别是Read Repeatable**，就是可重复读，就是说每个事务都会开启一个自己要操作的某个数据的快照，事务期间，读到的都是这个数据的快照罢了，对一个数据的多次读都是一样的。

**MySQL是如何实现Read Repeatable的？（可重复读）**<br />MySQL是通过MVCC机制来实现的，就是多版本并发控制，**multi-version concurrency control。**

当我们使用innodb存储引擎，会在每行数据的最后加两个隐藏列，一个保存行的创建时间，一个保存行的删除时间，但是这儿存放的不是时间，而是事务id，事务id是mysql自己维护的自增的，全局唯一。

事务id，在mysql内部是全局唯一递增的，事务id=1，事务id=2，事务id=3<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633960614209-00e32453-1ce8-4c17-a8cd-d4ab8445960b.png#clientId=u60afa8ee-640f-4&from=paste&height=202&id=u8a7ea34e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=175&originWidth=360&originalType=binary&ratio=1&size=4307&status=done&style=none&taskId=u69146689-735b-4b45-987a-73512baaa08&width=415.98577880859375)

事务id=121的事务，查询id=1的这一行的时候，一定会找到创建事务id <= 当前事务id的那一行<br />select * from table where id=1，就可以查到上面那一行<br />事务id=122的事务，将id=1的这一行给删除了，此时就会将id=1的行的删除事务id设置成122<br />事务id=121的事务，再次查询id=1的那一行，能查到吗？<br />能查到，要求创建事务id <= 当前事务id，当前事务id < 删除事务id<br />事务id=121的事务，查询id=2的那一行，查到name=李四<br />事务id=122的事务，将id=2的那一行的name修改成name=小李四<br />事务id=121的事务，查询id=2的那一行，答案是：李四，创建事务id <= 当前事务id，当前事务id < 删除事务id

在一个事务内查询的时候，mysql只会查询创建时间的事务id小于等于当前事务id的行，这样可以确保这个行是在当前事务中创建，或者是之前创建的；

同时一个行的删除时间的事务id要么没有定义（就是没删除），要么是必当前事务id大（在事务开启之后才被删除）；满足这两个条件的数据都会被查出来。

那么如果某个事务执行期间，别的事务更新了一条数据呢？这个很关键的一个实现，其实就是在innodb中，是插入了一行记录，然后将新插入的记录的创建时间设置为新的事务的id，同时将这条记录之前的那个版本的删除时间设置为新的事务的id。

现在get到这个点了吧？这样的话，你的这个事务其实对某行记录的查询，**始终都是查找的之前的那个快照**，因为之前的那个快照的创建时间小于等于自己事务id，然后删除时间的事务id比自己事务id大，所以这个事务运行期间，会一直读取到这条数据的同一个版本。

记住，聊到事务隔离级别，必须把这套东西给喷出来，尤其是mvcc，说实话，市面上相当大比重的java程序员，对mvcc是不了解的。<br />简而言之就是：**每个事物对应一个事物ID，对操作的那行数据做了一个版本快照，当这个事物还没有提交的时候，后面的事物ID就会去这个版本快照列表里面读取最早的数据，只要他还没提交。**<br />[

](https://blog.csdn.net/u013073869/article/details/105271345)


<a name="eDTo2"></a>
### 04. 你能说说MySql数据库锁的实现原理吗？若是死锁了怎么办？
myql 的锁的类型 ，通常是  表锁，行锁和页锁。

通常myisam会加表锁，就是myisam引擎下，执行查询的时候，会默认加个表共享锁，也就是表读锁，这个时候别人只能来查不能读写数据，myisam**写的时候，也会加个表独占锁**，也就是表写锁，别人不能读也不能写。<br />页级锁，通常也不多用。

重点聊一聊行锁，innodb引擎通常用行锁，可是也有表锁。

innodb的行锁有共享锁和排他锁两种：

- **共享锁**就是，多个事务均可以加共享锁，读同一行数据，可是别的事务不能写这行数据；
- **排他锁**，就是一个事务能够写这行数据，别的事务只能读，不能写。

insert,update,delete， innodb会自动给那一行加行级排他锁。<br />select,innodb啥锁都不加，由于innodb默认实现了可重复读，也就是mvcc（多版本并发控制机制），因此多个事务随便读一个数据，通常不会有冲突，你们读本身那个快照就能够了，不涉及到锁的问题。

注意innodb历来不会主动给本身加个共享锁，除非你手动加一个共享锁。

**悲观锁和乐观锁**<br />mysql里的悲观锁是走 select * from table where id =1 for update,意思就是我很悲观，我担忧本身拿不到这把锁，我必须先锁死，而后就我一我的能够干这个事儿，别人都干不了，不能加共享锁，也不能加排他锁。（悲观锁要少用，容易产生很严重的死锁问题）

乐观锁，就是不须要提早搞一把锁，可是在查询数据的时候加入版本号，接着再执行各类业务逻辑以后再修改，在修改的时候会比较当前版本号和我以前查出来的版本号是否是同样的，若是是同样的就修改而后将版本号加1，不然就不会更新任何一行数据，此时就从新查询后再次更新。

死锁：常见的死锁就是两个事务分别都持有一个锁，结果仍是去请求别人持有的那把锁，结果就是谁也出不来。<br />死锁如何排查：找dba看一下死锁日志，就ok了，而后根据对应的sql,找一下对应的代码，具体判断一下为何死锁了。 这次可以说说财务系统那次 DBA提交SQL死锁事故，怎么怼DBA的事情说说。



<a name="SHILF"></a>
### 05.MySQL的SQL调优通常都有哪些手段？大家通常怎么作？
看执行计划，判断有没有走索引。<br />在这个环节重点说下你对执行计划这块的理解就ok<br />explain select * from table，就ok了<br />table | type | possible_keys | key | key_len | ref | rows | Extra

- table：哪个表
- type：这个很重要，是说类型，all（全表扫描），const（读常量，最多一条记录匹配），eq_ref（走主键，一般就最多一条记录匹配），index（扫描全部索引），range（扫描部分索引）
- possible_keys：显示可能使用的索引
- key：实际使用的索引
- key_len：使用索引的长度
- ref：联合索引的哪一列被用了
- rows：一共扫描和返回了多少行
- extra：using filesort（需要额外进行排序），using
- temporary（mysql构建了临时表，比如排序的时候），using
- where（就是对索引扫出来的数据再次根据where来过滤出了结果）

[

](https://blog.csdn.net/u013073869/article/details/105271345)<br />生产环境中一般都会配置慢查询日志，自己公司，会每个月或者每周，负责人去检查一下慢查询日志，导出来，然后选择性优化。当做技术OKR处理。<br />可以讲讲自己当初为啥搭建 Soar Web 服务的过程。

<a name="ulNYG"></a>
### 06.分库分表、读写分离和主备切换分别是如何实现的？
主从同步的实现：首先主服务器将数据的变化记录到BinaryLog中，接下来从服务器会开启一个线程将主服务器中的数据操作同步到自己的RelayLog中，然后在开启一个线程执行该操作，更新从服务器中的数据。具体细致，后面去查查吧。这里只是当做复习使用而已。<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633961407871-5ac56f81-b7fb-4579-bf7b-fbf27da87ca6.png#clientId=u60afa8ee-640f-4&from=paste&height=465&id=uba866c05&margin=%5Bobject%20Object%5D&name=image.png&originHeight=524&originWidth=873&originalType=binary&ratio=1&size=166480&status=done&style=none&taskId=ud7395687-2dff-4fcb-932d-f2303b3c7bb&width=775.491455078125)
<a name="pAFlM"></a>
## 
<a name="svRUJ"></a>
## 涉及到的知识补充
<a name="AVc2s"></a>
### 单例设计模式
![](https://cdn.nlark.com/yuque/0/2021/jpeg/1461694/1633783579473-e0066ffc-e75b-4a83-8ea1-6f62be800124.jpeg#clientId=uf6950fa8-95d1-4&from=paste&id=u1e74e7e2&margin=%5Bobject%20Object%5D&originHeight=502&originWidth=748&originalType=url&ratio=1&status=done&style=none&taskId=u0a418230-698c-4dd4-8611-ae7e93d3a6b)
```java
/**
 * 饿汉式单例设计模式
 * 类一加载就有对象
 */
public class Single {
    //私有化构造函数
    private Single() {

    }
    //创建私有并静态的本类对象
    private static Single s = new Single();
    //定义公有并静态的方法
    public static Single getInstance() {
        return s;
    }
}

```
```java
//懒汉模式 需要的时候才会加载
public class Single2 {

    private Single2() {
        
    }
    private static Single2 s = null;

    public static Single2 getInstance() {
        if (s == null) {
            s = new Single2();
        }
        return s;
    }
}


```
[

](https://www.shangmayuan.com/tag/%E7%BC%96%E7%A8%8B/1.html)
<a name="ZMlBf"></a>
### Mybatis
<a name="sup5n"></a>
#### 01.Mybatis中的延迟加载
> 问题：在一对多中，当我们有一个用户，他有100个账户。
> 在查询用户的时候，要不要把关联的账户查出来？
> 
> 在查询账户的时候，要不要把关联的用户查出来？
> 
> 在查询用户时，用户下的账户信息应该是什么时候用，什么时候查询
> 在查询账户时，账户的所属用户信息应该是随着账户查询时一起查询	  出来的

- [ ] 什么是延时加载

 在真正使用数据是时才发起查询，不用的时候不查询。按需加载

- [ ] 什么是立即加载？

 只要查询就全部查询，通常一对多的情况下都会使用延时加载

<a name="PdRDZ"></a>
#### 02.Mybatis中的缓存
什么是缓存？ <br />存在于内存中的临时数据<br />为什么使用缓存？ <br />减少和数据库的交互次数，提高执行效率<br />什么样的数据适合使用缓存？ <br />经常查询并且不经常改变的。结果没有那么重要的。<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633961595186-3f8dd29a-c8b5-4c53-9f15-c2ec75b8938e.png#clientId=u60afa8ee-640f-4&from=paste&height=312&id=ued799209&margin=%5Bobject%20Object%5D&name=image.png&originHeight=485&originWidth=1180&originalType=binary&ratio=1&size=105972&status=done&style=none&taskId=u1f31de14-d4e1-4927-bf74-fa23aeacb89&width=760)<br />**一级缓存**<br />如果数据库中的信息和一级缓存中信息不一致是如何更新信息的？<br />一级缓存是SqlSession范围的缓存，当调用SqlSession的修改，添加，删除，commit(),close()等方法时就会清空一级缓存。

**二级缓存**<br />它指的是Mybatis中SqlSessionFactory对象的缓存。由同一个SqlSessionFactory创建的SqlSession共享其缓存。

**二级缓存的使用步骤：**<br />第一步：让Mybatis框架支持二级缓存（在SqlMapConfig.xml中配置）<br />第二步：让当前的映射文件支持二级缓存（在IUserDao.xml中配置）<br />第三步：让当前的操作支持二级缓存（在select标签中配置）<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633961651936-0491d1bb-a689-490c-994d-86854b48c3e0.png#clientId=u60afa8ee-640f-4&from=paste&height=857&id=u444ae53b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=725&originWidth=645&originalType=binary&ratio=1&size=120075&status=done&style=none&taskId=ub2c18a14-785f-4d9f-b4ca-45a05d4afbe&width=762.4971313476562)<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633961683081-ae3d7873-e2e9-44c5-9b89-86ee5bf2ee29.png#clientId=u60afa8ee-640f-4&from=paste&height=326&id=u3bf14d4e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=472&originWidth=1256&originalType=binary&ratio=1&size=32055&status=done&style=none&taskId=u7421f8aa-c2ef-40af-b17d-f27a72403f6&width=867.991455078125)



<a name="ozqtQ"></a>
### 视频个人总结

<a name="ex9Vy"></a>
#### HashMap里面怎么优化Hash冲突的？
简单来说，让高低16位都参与运算，减少高16位值相近的情况，扩大在取模中的值差异，减少hash碰撞的概率，让Key存储分布更加均匀。<br />另一方面，如果Key冲突了，那就存在链表里面，如果链表的长度超过8 就开始做红黑二叉树转换。如果链表长度减少到6就开始从二叉树转变为链表。

<a name="AkDJl"></a>
####  为什么是HashMap中链表超过8个节点后，才会转为红黑二叉树？
红黑树的平均查找长度是log(n)，长度为8，查找长度为log(8)=3，链表的平均查找长度为n/2，当长度为8时，平均查找长度为8/2=4，这才有转换成树的必要；链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。<br />还有选择6和8的原因是：中间有个差值7可以防止链表和树之间频繁的转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。

<a name="Yp8V6"></a>
#### HashMap是如何进行扩容的？
底层数组，当数组满了后，就自动扩容： 2倍扩容。<br />里面的元素重新进行reHash(),落到同的数组位置。<br />所有节点通过  （新数组的长度-1） & hash值  = 所落的数组节点（key的hash值与（长度-1）做与运算 ）

<a name="k4S6v"></a>
#### 为什么HashMap里面的负载因子是0.75？
> 说到这里其实要知道hashmap里面的阈值是 thershold = loadFactor*capacity 的；而默认的loadFactor是0.75，官网解释是说泊松分布算出来的，其实不然，这里泊松分布算出来的树出现的概率，当树化的阈值是8，加载系数是0.75的时候 出现树化的概率为 0 .00000006，jdk开发设计hashmap的时候，为了平衡树和链表的性能（树比链表遍历快，但是树的结点是链表结点大小的两倍，所以当树出现的概率比较小的时候的性价比就高了，所以取加载系数的时候平衡了下性能 取0.75）。平衡性能其实就是平衡时间与空间 个人认为。
> 原注释的内容和目的都是为了解释在java8 HashMap中引入Tree Bin（也就是放入数据的每个数组bin从链表node转换为red-black tree node）的原因
> 原注释：Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use(see TREEIFY_THRESHOLD).
> TreeNode虽然改善了链表增删改查的性能，**但是其节点大小是链表节点的两倍**
> 虽然引入TreeNode但是不会轻易转变为TreeNode（如果存在大量转换那么资源代价比较大），根据泊松分布来看转变是小概率事件，性价比是值得的
> 泊松分布是二项分布的极限形式，两个重点：事件独立、有且只有两个相互对立的结果
> 泊松分布是指一段时间或空间中发生成功事件的数量的概率
> 对HashMap table[]中任意一个bin来说，存入一个数据，要么放入要么不放入，这个动作满足二项分布的两个重点概念
> 对于HashMap.table[].length的空间来说，放入0.75*length个数据，某一个bin中放入节点数量的概率情况如上图注释中给出的数据（表示数组某一个下标存放数据数量为0~8时的概率情况）
> 举个例子说明，HashMap默认的table[].length=16，在长度为16的HashMap中放入12（0.75*length）个数据，某一个bin中存放了8个节点的概率是0.00000006
> 扩容一次，16*2=32，在长度为32的HashMap中放入24个数据，某一个bin中存放了8个节点的概率是0.00000006
> 再扩容一次，32*2=64，在长度为64的HashMap中放入48个数据，某一个bin中存放了8个节点的概率是0.00000006
> 所以，当某一个bin的节点大于等于8个的时候，就可以从链表node转换为treenode，其性价比是值得的。

**简单来说就是：负载因子使用0.75是符合概率学统计的，符合“泊松分布”定律，平衡树与链表的性能，平衡时间与空间，因为二叉树的节点是链表节点的两倍大小，为了防止频繁裂变，减少资源损耗。**


<a name="QSnLo"></a>
#### courrentHashMap的底层实现原理？里面做过什么优化？

- 1.7锁的优化，由整个数组加锁，变成 分段数组 （桶）加锁，降低了锁的粒度
- 1.8锁的优化，由分段加锁，优化成对数组元素加锁，锁的是元素节点下的链表或红黑树，降低了锁的粒度。

分段加锁，对数组每个元素执行CAS策略，加锁比较，然后put值进去，保证元素的安全性。<br />保证同一时间只有一个线程能对单个数组做put进去。只有对同一个数组节点才生效。

<a name="oREEc"></a>
#### HashMap线程不安全的体现？
courrentHashMao的加锁原理和HashTable有什么区别？


<a name="b6hGd"></a>
#### synchronized 关键字的底层原理？
javac 编译之后，会对代码增加一个锁标记，
> monitorenter(加锁) {	
> XXXXX你的业务代码      
> }monitorexit(释放锁)

每个对象都有个关联的monitor，里面有个计数器，如果是0就没加锁，1就是加锁，如果又反复加锁，就是2，数字+1，  （但是什么场景下用到了重入锁呢？）

- [ ] 里面对内存屏障，CPU类的硬件级别，原子性，可见性，指令重排，等这又是如何实现的呢？

- [ ] synchronize锁的优化是什么样的？

- [ ] synchronize锁的升级过程是怎么样的？

<a name="LTJSv"></a>
#### CAS的理解，以及底层实现原理？
JVM并发包里的原子类：AtomicInteger ，底层就是基于CAS实现的。<br />实现原理就相当于乐观锁，在修改值的时候，先查询出来，然后比较是否和之前查的一致，一致就修改，不一致就继续取值然后进行第二次比较，修改。（简而言之就是先比较，后修改）

- [ ] 什么是ABA问题？ 

- [ ] 什么CPU里面的是缓存一致性协议：MESI协议？

- [ ] 什么是MESI嗅探机制？

<a name="ciUuB"></a>
#### 
对JDK中的AQS理解，以及底层实现原理。<br />ReentrantLock 锁，底层就是基于AQS来实现的。<br />reentrantLock.lock();<br />reentrantLock.unlock();<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1634020988764-9a8b5464-35cc-46b4-88fe-7be7405d08cd.png#clientId=ud7f4f27e-3f20-4&from=paste&height=511&id=u671400bd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1021&originWidth=1305&originalType=binary&ratio=1&size=348432&status=done&style=none&taskId=ue93fcba8-f515-4375-bbe6-3b5dcceb519&width=652.5)


<a name="kVToH"></a>
#### 线程池的底层工作原理？
避免频繁的创建销毁线程。<br />ExecutorService ex = new Executors.newFixedThreadPool(10);<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1634021021465-e5c7eee9-856b-412d-bcd2-3efbdc975691.png#clientId=ud7f4f27e-3f20-4&from=paste&height=288&id=u4c073bb6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=204&originWidth=489&originalType=binary&ratio=1&size=52040&status=done&style=none&taskId=ub7b58adb-a5ec-4180-a131-73ca9a0334f&width=690.4886322021484)


<a name="GDIVm"></a>
#### 线程池中使用无界队列，可能会发生什么事情？
OOM，任务无限创建。


<a name="agfgB"></a>
#### 线程池的队列满了后，会发生什么事情？
1.线程最大限制没有限制，就会无限创建线程，出现栈内存缺少。<br />2.出现OOM<br />3.启动线程池配置的拒绝策略


<a name="Noo0g"></a>
#### 如果线上机器宕机，线程池中的阻塞队列中的请求怎么办？
在插进入线程池时前，先用数据库记录这个请求的状态，然后在调用线程池，最后更新他的状态，已提交，未提交，已完成。等等。最后在服务重启的时候，重新扫描一下表中的数据库记录，重新把任务提交一下。<br />其实这也不一定是比较完美的状态，影响性能，而且万一在未提交的时候就丢失了呢？


- [ ] 如何实现两个线程的交替执行？




<a name="whnTc"></a>
#### 其他乱七八糟的笔记：

Java内存模型中的原子性，有序性，可见性是什么？<br />可见性：就是上面的JVM内存读改模型，当线程A拿到值修改之后，立马要让线程B知道，这个值以及修改了，这就是实现内存的可见性。（那么这又是怎么实现的呢？）

原子性：就是data++,是独立执行的，不受外界影响，要么成功，要么失败，具有结果是具有不可分割性。<br />有序性：代码编译的时候，可能会对指令进行重排，提高效率。<br />要想具备有序性，可以加锁，可以用volatile 等。具体去百度查一下。


volatile关键字的作用？<br />解决变量内存的可见性，有序性，可以有限的保证原子性，但不全是。

volatile关键字的原理？<br />当volatite关键字修改后，主内存的值会刷新到CPU的缓存里面，那么这里是怎么刷新的呢？<br />这里又什么是MESI嗅探机制呢？

什么是happen-before原则？ <br />就是因为在CPU运行指令的时候，有可能会做指令重排，于是乎JVM就规定了happen-before的几个原则，以此保证代码的执行顺序。

happen-before的八大原则？<br />简而言之：就是在特殊情况下，不允许CPU指令重排，大概就是Volatile，线程的执行过程，加锁的过程，以及不允许重排的传递原则。<br />原则1：程序次序规则：一个线程内，按照代码顺序，书写在前面的操作一定在前面执行。<br />原则2：锁定规则：unlock 一定在 lock 后面<br />原则3：volatile原则：对一个volatile变量的写操作一定比后面的读操作先发生，在指令重排问题上会保证先写后读。<br />原则4：传递规则：A先与B，B先于C，那么A一定先于C。<br />原则5：线程启动规则：比如Thread的start 方法 一定先发生与run 方法。<br />原则6：线程中断规则：对线程的interrupt方法的调用，先行发生于被中断线程的代码检测到中断时间的发生<br />原则7：线程终结规则：线程中所有的操作，都发生于线程线程的终止检测，可通过join方法结束，isAlive（）方法的返回值手段检测到线程终止与执行。<br />原则8：对象终结规则：一个对象的初始化完成先行发生于发的finalize() 方法的开始。

什么是内存屏障？<br />内存屏障：就是禁止指令重排。简单来说就是缩短 read load use，assgin  store write 这几个过程，达到值被修改后，就能立马加载到堆内存中。

什么是lock指令？	volatile是如何保证可见性的？<br />对volatile修饰的变量。执行写操作的话，JVM会发生一条lock前缀指令给CPU，CPU在计算完之后会立即将这个值会写到主内存，同时因为有MESI缓存一致性协议，所有各个CPU都会对总线进行嗅探，自己本地缓存中的数据是否被别人修改。<br />如果发现修改了某个MESI缓存上的数据，那么CPU就会将自己本地缓存数据过期，然后CPU重新读取，加载最新的数据。<br />简而言之：lock前缀指令做CPU标记，加快值的会写  ，MESI 缓存一致性协议 嗅探缓存中数据是否被修改。<br />关键字：lock前缀指令 ， MESI缓存一致性协议，MESI嗅探机制



SpringIOC机制和AOP机制的理解？

Spring 中的bean是线程安全的吗？<br />绝大部分是线程不安全的，因为默认是单例对象，在多个线程操作下会导致线程不安全的情况。<br />如果把作用域范围缩小的话，有可能会实现线程安全，<br />bean的5个作用域范围？

Spring事务的实现原理？<br />Spring事务的传播特性，什么是默认传播特性？

Spring 的核心架构，容器化管理，反射技术，bean的生命周期等等。

Spring中使用了哪些设计模式？<br />工厂模式，单例模式，代理模式<br />这几个模式分别在哪些场景下使用了?<br />SpringIOC就是一个容器，就相当于是一个工厂模式，把所有的bean都放在容器里，相当于一个大工厂。<br />Bean的默认作用域就是单例，这里就是单例模式。

SpringBoot的自动装配过程？

说说SpringMVC的核心架构图？



ISO网络七层模型？<br />TCP，IP四层模型？<br />网络四层模型？


浏览器请求地址后经历了一个什么过程？<br />画个图


什么是长连接？<br />什么是短连接？

MYSQL存储引擎有哪些？<br />innodb  ，Mysicam，memmoy, HashMap引擎。

MYSQL索引实现原理？<br /> 

MySQL事物的原则<br />ACID<br />MYSQL 事务的隔离级别<br />读未提交<br />读已提交<br />可重复读  （默认，什么是MVCC 多版本控制机制。）<br />幻读   <br />串行化

Mysql 数据库锁的实现原理？

共享锁？<br />排他锁？<br />乐观锁？<br />悲观锁?

进程之间如何通信？

什么是共享内存？

线程间如何切换？

NIO，BIO，AIO之前的区别？

BIO<br />NIO的通信原理？<br />多路复用。。。<br />AIO<br />读取时同步的

同步阻塞，同步非阻塞，异步非阻塞？

Linux上的资源告警问题排查等。

在谈谈Java的原子性，精确到硬件级别<br />volatile,synchronize的底层硬件原理。

Java语言里面所有的 int=1；char = 'a'; 这样的赋值操作都是原子操作的，但是也有一下两种特例。<br />原子性这块的特例  ：<br />long ,double 在32位的虚拟机里面，赋值操作不是原子操作，因为他两是64位的。<br />如果多个线程同时并发执行 long =30L ； 操作的时候，就会可能出现一个线程在修改高32位，另一个线程在修改低32位，导致修改错乱。<br />为了解决就可以加上volatile修饰long i = 1 ; double a =1.0;  就能保证在32位虚拟机 里可实现原子性操作。<br />但是  i++ ; 是不能保证原子性的，他是线程不安全的，就算对i 修饰了volatile也不是原子性的。。

所以？ 是不是在全局变量的代码里，记得对Long double 加上volatile关键字？


可见性涉及的底层硬件原理？<br />可见性的第一个问题：<br />在寄存器级别，导致变量副本发生变化

Java有两种编译器<br />静态编译器 JavaC // 把Java文件变成class字节码，一般是编译我们写的代码。<br />动态编译器 JIT // 负责把.class文件中的字节码编译为JVM所在操作系统支持的机器码，程序运行过程总进行编译。

指令重排的几个层次？<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1461694/1633785711424-6c3c061b-7592-443d-b602-3d0714904b30.png#clientId=udf036431-c251-4&from=paste&height=465&id=u6cd2d6c1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=930&originWidth=1988&originalType=binary&ratio=1&size=1266076&status=done&style=none&taskId=uefcb7be8-caba-42c8-8130-41200d9e2f7&width=994)





